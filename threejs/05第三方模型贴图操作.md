---
outline: deep

prev:
  text: "第三方模型操作"
  link: "/threejs/04第三方模型操作"
next:
  text: "文字和粒子效果"
  link: "/threejs/06文字和粒子效果"
---

## 第三方模型贴图

根据模型获取对应的网格进行操作,例如: 网格换色、贴图、隐藏部位等

### index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>05第三方模型贴图操作</title>
    <script type="module" src="./index.ts"></script>
    <style>
      body {
        width: 100vw;
        height: 100vh;
        margin: 0;
        padding: 0;
      }
      .cantainer {
        width: 100%;
        height: 100%;
        position: relative;
      }
      .color-pick {
        width: 32px;
        max-height: calc(100%-40px);
        position: absolute;
        left: 20px;
        top: 20px;
        background: #f9f9f9;
        border: 1px solid #ccc;
      }
      .textures {
        /* width: 200px; */
        max-height: calc(100%-40px);
        position: absolute;
        right: 20px;
        top: 20px;
        background: #f9f9f9;
        border: 1px solid #ccc;
        padding: 10px;
      }
      .upload {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .upload-img {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="cantainer">
      <canvas id="canvas" style="width: 100%; height: 100%"></canvas>
      <div class="color-pick"></div>
      <div class="textures">
        <div class="upload">
          <input
            type="file"
            accept="image/*"
            class="uploadFile"
            style="display: none"
          />
          <img src="" alt="上传照片" class="upload-img" />
          <button type="button" class="uploadBtn">上传</button>
          <button type="button" class="clearBtn">清空</button>
        </div>
        <div class="chang-location">
          <div>
            <label name="x">X轴偏移</label>
            <input
              type="number"
              class="location-x"
              name="x"
              step="0.1"
              value="0"
            />
          </div>
          <div>
            <label name="y">Y轴偏移</label>
            <input
              type="number"
              class="location-y"
              name="y"
              step="0.1"
              value="0"
            />
          </div>
          <button class="set-location">应用</button>
        </div>
      </div>
    </div>
  </body>
</html>
```

### 处理颜色(color.ts)

```ts
import * as THREE from "three";

const color = [
  "rgb(255,255,255)",
  "rgb(255,192,203)",
  "rgb(220,20,60)",
  "rgb(138,43,226)",
  "rgb(0,0,255)",
  "rgb(0,191,255)",
  "rgb(0,255,0)",
];

const colorPick = (scene: THREE.Scene) => {
  const dom = document.querySelector(".color-pick") as HTMLDivElement;
  color.forEach((color) => {
    const colorItemDom = document.createElement("div");
    colorItemDom.style.width = "30px";
    colorItemDom.style.height = "30px";
    colorItemDom.style.cursor = "pointer";
    colorItemDom.style.margin = "5px 0px";
    colorItemDom.style.background = color;
    colorItemDom.style.border = "1px solid #ccc";
    colorItemDom.style.borderRadius = "50%";
    dom.appendChild(colorItemDom);

    // 添加事件
    colorItemDom.addEventListener("click", (e) => {
      // 获取车架对应的网格
      scene.traverse((child) => {
        if (child instanceof THREE.Mesh && child.name !== "floor") {
          // 设置所选颜色
          child.material.color.set(color);
        }
      });
    });
  });
};

export default colorPick;
```

### 处理贴图部位(texture.ts)

```ts
import * as THREE from "three";

/**
 * 上传文件
 * @param scence
 */
const uploadfile = (scence: THREE.Scene) => {
  const fileInput = document.querySelector(".uploadFile") as HTMLElement;
  const uploadBtn = document.querySelector(".uploadBtn") as HTMLElement;
  const clearBtn = document.querySelector(".clearBtn") as HTMLElement;
  const img = document.querySelector(".upload-img") as HTMLImageElement;

  // 点击上传按钮时，触发文件选择对话框
  uploadBtn.addEventListener("click", () => {
    fileInput.click();
  });

  // 获取文件
  fileInput.addEventListener("change", (e) => {
    const target = e.target as HTMLInputElement;
    const file = target.files?.[0] as File;
    const fileReader = new FileReader();
    // img -> base64
    fileReader.onload = (e) => {
      const base64 = e?.target?.result as string;
      // base64 -> image , 如果没有image标签，可以使用这个
      // const image = new Image()
      // image.src = base64
      // console.log(image);
      img.src = base64;

      // 创建贴图
      const texture = new THREE.Texture(img);
      // texture.offset.set(2.1, 0); // 起始位置：UV (0.3, 0.3)，调整到中间偏下
      // texture.repeat.set(0.4, 0.4); // 覆盖范围：0.4 x 0.4 的区域，限制在胸部区域
      // texture.wrapS = THREE.ClampToEdgeWrapping; // 防止纹理重复，边缘拉伸
      // texture.wrapT = THREE.ClampToEdgeWrapping; // 防止纹理重复，边缘拉伸
      // 打开更新纹理, 否则上传其他的时候有问题
      texture.needsUpdate = true;
      // 在场景中添加贴图
      scence.traverse((child) => {
        if (child instanceof THREE.Mesh && child.name != "floor") {
          // 将贴图添加到网格上
          child.material.map = texture;

          // child.material.map.offset.x = 0
          // child.material.map.offset.y = 0
        }
      });
    };
    fileReader.readAsDataURL(file);
  });

  // 清空文件
  clearBtn.addEventListener("click", () => {
    console.log("清空贴图");
    img.src = "";
    // 在场景中置空贴图
    scence.traverse((child) => {
      if (child instanceof THREE.Mesh && child.name != "floor") {
        // 置空贴图
        child.material.map = null;
        // 更新纹理
        child.material.needsUpdate = true;
      }
    });
  });
};

/**
 * 设置贴图位置
 * @param scence
 */
const setLocation = (scence: THREE.Scene) => {
  const xInput = document.querySelector(".location-x") as HTMLInputElement;
  const yInput = document.querySelector(".location-y") as HTMLInputElement;
  const btn = document.querySelector(".set-location") as HTMLButtonElement;
  btn.addEventListener("click", () => {
    const x = parseFloat(xInput.value);
    const y = parseFloat(yInput.value);
    scence.traverse((child) => {
      if (child instanceof THREE.Mesh && child.name != "floor") {
        const material = child.material as THREE.MeshLambertMaterial;
        if (material.map) {
          // 设置贴图位置
          material.map.repeat.set(x, y);
          // material.map.offset.set(x, y)
          // 更新贴图
          material.map.needsUpdate = true;

          // 重复贴图
          // material.map.wrapS = THREE.RepeatWrapping // 水平重复
          // material.map.wrapT = THREE.RepeatWrapping // 垂直重复
        }
      }
    });
  });
};

/**
 * 贴图管理
 * @param scence
 */
const textureManager = (scence: THREE.Scene) => {
  // 上传贴图
  uploadfile(scence);
  setLocation(scence);
};

export default textureManager;
```

### index.ts

```ts
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

import colorPick from "./color"; // 换色处理
import textureManager from "./texture"; // 贴图管理

// 创建场景
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf1f1f1);

// 创建相机
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 10, 10);
camera.lookAt(0, 0, 0);
scene.add(camera);

// 添加环境光, 环境光太强，物体会看起来比较劣质
const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
scene.add(ambientLight);
// 添加平行光源
const DirectionalLight = new THREE.DirectionalLight(0xffffff, 1);
DirectionalLight.position.set(5, 5, 5);
DirectionalLight.castShadow = true; // 投射阴影
DirectionalLight.shadow.mapSize.width = 1024; // 设置阴影的大小
DirectionalLight.shadow.mapSize.height = 1024; // 设置阴影的大小
scene.add(DirectionalLight);
// 补光，可以看到背后
const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.5);
fillLight.position.set(0, 0, -10);
scene.add(fillLight);

// 添加地板，方便映射阴影
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(30, 30),
  // MeshLambertMaterial兰伯特材质 受光照影响
  // MeshStandardMaterial标准材质 受光照影响
  // transparent: 允许透明, 不开的话,opacity无效
  new THREE.MeshLambertMaterial({
    color: 0xcccccc,
    opacity: 0.5,
    transparent: true,
  })
);
// 添加网格名
floor.name = "floor";
// 将网格旋转
floor.rotation.x = -Math.PI / 2; // 90度, 2π = 360°计算方式
floor.position.y = -1;
floor.position.z = -5;
// 接收阴影, 加载的模型也必须开启和投射阴影, 然后在渲染器开启阴影和配置开灯光阴影
floor.receiveShadow = true;
scene.add(floor);

// 加载模型
const loader = new GLTFLoader();
loader.load("./assets/scene.gltf", (gltf) => {
  // 将模型放大
  gltf.scene.scale.set(3, 3, 3);
  // 开启和接收阴影
  gltf.scene.traverse((childMesh) => {
    if (childMesh instanceof THREE.Mesh) {
      childMesh.castShadow = true; // 投射阴影, 然后在渲染器开启阴影和配置开灯光阴影
      childMesh.receiveShadow = true; // 接收阴影, 然后在渲染器开启阴影和配置开灯光阴影
    }
  });
  // 换色处理
  colorPick(scene);
  // 贴图管理
  textureManager(scene);
  // 将加载的模型的场景添加到当前场景中
  scene.add(gltf.scene);
});

// 添加辅助线
// const axesHelper = new THREE.AxesHelper(5);
// scene.add(axesHelper)

// 创建渲染器
const render = new THREE.WebGLRenderer({
  canvas: document.querySelector("#canvas") as HTMLCanvasElement,
  antialias: true,
});
render.setSize(window.innerWidth, window.innerHeight);
render.render(scene, camera);
render.setPixelRatio(window.devicePixelRatio);
// 渲染器开启阴影
render.shadowMap.enabled = true; // 开启阴影
render.shadowMap.type = THREE.PCFSoftShadowMap; // 高质量软阴影, 比较自然
render.toneMapping = THREE.ACESFilmicToneMapping; // aces色调映射，电影级别
render.toneMappingExposure = 1.0; // 色调映射曝光度

// 创建控制器
const controls = new OrbitControls(camera, render.domElement);

// 渲染
const animate = () => {
  requestAnimationFrame(animate);
  render.render(scene, camera);
  controls.update();
};

animate();
```
