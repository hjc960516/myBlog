---
outline: deep

prev:
  text: "文字和粒子效果"
  link: "/threejs/06文字和粒子效果"
next:
  text: "全景VR"
  link: "/threejs/08全景VR"
---

## 模型公路流线和电梯上色

调用`模型的电梯动画`和给`公路流线型上色`并给`公路的流线条`添加动画

### elevator.js

处理电梯的动画

```js
import * as THREE from "three";
import type { GLTF } from "three/examples/jsm/loaders/GLTFLoader.js";

/**
 * 处理电梯的材质以及发光
 * @param scene
 * @param gltf
 * @param meshArr
 * @returns {THREE.AnimationMixer | THREE.AnimationMixer[]}
 */
const handleElevator = (
  scene: THREE.Scene,
  gltf: GLTF,
  meshArr: THREE.Mesh[]
): THREE.AnimationMixer[] => {
  // 动画
  const animations = gltf.animations;

  console.log(animations);

  // 动画混合器数组
  const mixerArr: THREE.AnimationMixer[] = [];

  // 遍历网格并创建动画混合器和动画
  meshArr.forEach((item, index) => {
    // 1. 动画
    // 创建动画混合器
    const mixer = new THREE.AnimationMixer(item);
    // 创建动画
    const animation = mixer.clipAction(animations[index]);
    // 播放动画
    animation.play();
    // 将动画混合器添加到数组
    mixerArr.push(mixer);

    console.log(item, mixer, animation, animations[index]);

    // 2. 换色
    // 创建新的材质
    const newMaterial = new THREE.MeshBasicMaterial({
      color: "red",
      transparent: true,
      opacity: 0.3,
    });
    item.material = newMaterial;

    // 3. 更新线的颜色
    // 线的材质
    const newLine = new THREE.LineBasicMaterial({
      color: "pink",
      transparent: true,
      opacity: 0.5,
    });

    // 如果多个网格就创建一个组
    const group = new THREE.Group();

    // 通过网格遍历提取边缘, 周边的线
    item.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        // 提取边缘, 周边的线
        const edges = new THREE.EdgesGeometry(child.geometry);

        // 将线的材质添加到组中
        const lineMaterial = new THREE.LineSegments(edges, newLine);
        group.add(lineMaterial);

        // 将网格添加到组中
        const lineMseh = new THREE.Mesh(child.geometry, newMaterial);
        group.add(lineMseh);

        // 将所有网格添加到场景
        item.add(group);
      }
    });
  });
  return mixerArr;
};

export default handleElevator;
```

### road.js

给公路上色，并且将流线动起来

```js
import * as THREE from "three";
import type { GLTF } from "three/examples/jsm/loaders/GLTFLoader.js";
import { interpolateHsl } from "d3-interpolate"; // 处理颜色, interpolateHsl: 处理颜色渐变，三原色算法
import TWEEN from '@tweenjs/tween.js' // 动画库，@typs/three自带
/**
 * 处理电梯的材质以及发光
 * @param scene
 * @param gltf
 * @param meshArr
 * @returns {THREE.AnimationMixer | THREE.AnimationMixer[]}
 */
const handleRoad = (scene: THREE.Scene, gltf: GLTF, meshArr: THREE.Mesh[]): typeof TWEEN => {
  // 遍历四条公路
  meshArr.forEach(mesh => {
    // 创建材质变颜色
    // vertexColors自定义顶点颜色 可以实现渐变
    // BackSide是因为模型材质改色的时候也设置了
    const basicMaterial = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide })

    // 获取公路的网格
    mesh.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        // 克隆原来的几何体，不改变原来的材质，新的几何体可以覆盖到几何上实现公路颜色渐变
        const geo = child.geometry.clone()
        // 获取几何体的顶点数量
        const count = geo.attributes.position.count
        // 颜色, 变色, #00ffff -> #000000, 返回的是rgb(x,x,x)
        const newColor = interpolateHsl('#00ffff', '#000000')
        // 创建颜色数组, *3 是因为每个顶点是由rgb(x,x,x) 转换为 [r,g,b]
        const colorArr = new Float32Array(count * 3)

        // 创建随机锚点，切割公路分段
        const anchor = Number((Math.random() * count).toFixed(0))

        // 遍历每个顶点
        for (let i = 0; i < count; i++) {
          // 渐变色的间隔值
          const t = i / count
          // 获取当前渐变速度的颜色, 结果是rgb(r, g, b)
          const color = newColor(t)
          // 将 rgb(r, g, b) 变为 [r,g,b]
          const rgb = color.match(/\d+/g) as string[]
          colorArr[i * 3] = Number(rgb[0]) / 255 // r
          colorArr[i * 3 + 1] = Number(rgb[1]) / 255 // g
          colorArr[i * 3 + 2] = Number(rgb[2]) / 255 // b

        }
        // 切割段
        const first = colorArr.slice(anchor * 3)
        const second = colorArr.slice(0, anchor * 3)
        // 两段组成完整公路顶点
        const newColorArray = [...first, ...second]
        // 将颜色设置到几何体
        geo.setAttribute('color', new THREE.Float32BufferAttribute(newColorArray, 3))
        // 创建新的网格
        const newMesh = new THREE.Mesh(geo, basicMaterial)
        // 将原本公路网格的东西都复制到新的网格上
        newMesh.rotation.copy(child.rotation) // 旋转
        newMesh.position.copy(child.position) // 位置
        newMesh.scale.copy(child.scale) // 播放
        // 添加到场景
        scene.add(newMesh)

        // 创建动画, 为什么要使用setInterval，因为数组播放完了动画会停止，需要不停衔接
        setInterval(() => {
          // 创建一个tween对象，从0-1 5秒一次, 时间要与setInterval一致
          new TWEEN.Tween({ value: 0 }).to({ value: 1 }, 5000)
            .onUpdate((val) => {
              // 重复切割段
              const ahhor = Number((val.value * count).toFixed(0))
              // 切割段
              const first = colorArr.slice(ahhor * 3)
              const second = colorArr.slice(0, ahhor * 3)
              // 两段组成完整公路顶点
              const newColorArray = [...first, ...second]
              // 将颜色设置到几何体
              geo.setAttribute('color', new THREE.Float32BufferAttribute(newColorArray, 3))
            })
            .start()
        }, 5000)
      }
    })
  })

  return TWEEN
}


export default handleRoad
```

### index.js

```js
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

import handleEvevator from "./utils/elevator";
import handleRoad from "./utils/road";
import TWEEN from "@tweenjs/tween.js"; // 动画库，@typs/three自带

// 创建场景
const scene = new THREE.Scene();

// 动画混合器数组
let mixerArr: THREE.AnimationMixer[] = [];
// 公路动画
let roadAnimation: typeof TWEEN | undefined;

// 创建相机
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  800
);
// 相机位置
camera.position.set(3, 3, 1);
// 相机添加到场景
scene.add(camera);

// 平行光
const light1 = new THREE.DirectionalLight(0xffffff, 1);
light1.position.set(3, 3, 3);
scene.add(light1);

// 加载模型
const loader = new GLTFLoader();
loader.load("./assets/b-city.glb", (gltf) => {
  // 将模型添加到当前场景
  scene.add(gltf.scene);

  // 电梯网格
  const elevatorMesh: THREE.Mesh[] = [];
  // 公路网格
  const roadMesh: THREE.Mesh[] = [];
  // 更改的材质
  const newMaterial = new THREE.MeshBasicMaterial({
    color: new THREE.Color("#1f56b9"),
    transparent: true, // 开启透明度
    opacity: 0.3, // 透明度
    side: THREE.BackSide, // 可视面, DoubleSide: 正反面; FrontSide: 正面; BackSide: 反面
  });

  // 获取所有网格
  gltf.scene.traverse((child) => {
    if (child instanceof THREE.Mesh) {
      console.log(child.name);

      // 筛选网格归类
      if (child.name.includes("Elevator")) {
        elevatorMesh.push(child);
      }
      if (child.name.includes("road")) {
        roadMesh.push(child);
      }

      // 将所有网格替换新的网格
      child.material = newMaterial;
    }
  });

  // 电梯处理
  const evevatorMixers = handleEvevator(scene, gltf, elevatorMesh);
  mixerArr = mixerArr.concat(evevatorMixers);

  // 公路处理
  roadAnimation = handleRoad(scene, gltf, roadMesh);
});

// 创建渲染器
const render = new THREE.WebGLRenderer({
  // canvas: document.querySelector('canvas') as HTMLCanvasElement // 添加canvas到渲染器
  antialias: true, // 抗锯齿
});
// 设置渲染器大小
render.setSize(window.innerWidth, window.innerHeight);
// 自适应像素
render.setPixelRatio(window.devicePixelRatio);
// 添加canvas到渲染器，如果没有会自动创建
document.body.appendChild(render.domElement);

// 创建辅助线
const axesHelper = new THREE.AxesHelper(10);
scene.add(axesHelper);

// 创建控制器
const controls = new OrbitControls(camera, render.domElement);

// 创建时间
const clock = new THREE.Clock();

/**
 * 轮询动画函数
 */
const animate = () => {
  const deltaTime = clock.getDelta();
  // 更新控制器
  controls.update();
  // 更新电梯动画
  // 注意clock.getDelta() 不能直接放到update()里面，因为getDelta是根据上次调用时间来重置内部的时间
  // 同一帧内，遍历时重复调用该函数，导致时间间隔过小，容易无限趋向于0，所以会导致只有第一个动画有效果，而其他没效果
  mixerArr.forEach((mixer) => mixer.update(deltaTime));
  // console.log(mixerArr);
  // 更新公路动画
  roadAnimation?.update();
  // 更新渲染器
  render.render(scene, camera);
  requestAnimationFrame(animate);
};

animate();
```
