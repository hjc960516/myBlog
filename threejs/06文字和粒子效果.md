---
outline: deep

prev:
  text: "第三方模型贴图操作"
  link: "/threejs/05第三方模型贴图操作"
next:
  text: "模型公路流线和电梯上色"
  link: "/threejs/07模型公路流线和电梯上色"
---

## 文字和粒子效果

### 文字

`文字`不像其他的有独立的`API`，而是通过`FontLoader`加载`字体文件`和`TextGeometry`来加载字体，而且`FontLoader`只能接受`json`文件

#### 字体文件

一般字体文件都是`.ttf`,`.otf`,`.woff`,`.woff2`等格式，所以需要转成`json`文件格式的,

1. [官方字体文件](https://threejs.org/examples/fonts/helvetiker_bold.typeface.json)
2. [字体格式转 json 格式网站](https://gero3.github.io/facetype.js/)

### 粒子效果(Points)

`粒子`是使用`Points粒子网格`来实现，通过`BufferGeometry`去进行自定义`点`的位置、大小等等

### 文字和粒子效果实现

自己去网上找一个字体文件，然后去网站将字体文件转为`json`文件

#### html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>06文字和粒子效果</title>
    <script type="module" src="./index.ts"></script>
    <style>
      body,
      html,
      .container {
        /* dvw和dvh是基于vw和vh，但是在移动端时会动态计算头部和底部导航栏宽高度 */
        width: 100dvw;
        height: 100dvh;
        padding: 0;
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <canvas id="canvas" style="width: 100%; height: 100%"></canvas>
    </div>
  </body>
</html>
```

#### ts

```ts
import * as THREE from "three";
import { FontLoader } from "three/examples/jsm/loaders/FontLoader.js"; // 加载字体文件
import { TextGeometry } from "three/examples/jsm/geometries/TextGeometry.js"; // 字体
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

// 创建场景
const scense = new THREE.Scene();
// 设置背景
scense.background = new THREE.Color("#808080");

// 创建相机
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
// 设置相机位置
camera.position.set(0, 0, 10);
//  将相机添加到场景中
scense.add(camera);

// 创建辅助线
const axesHelper = new THREE.AxesHelper(10);
// 将辅助线添加到场景
scense.add(axesHelper);

// 添加平行光照
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(10, 10, 10);
scense.add(light);

// -------------------------------- 字体---------------------
// 加载字体文件
const fontLoader = new FontLoader();
fontLoader.load("./assets/font.json", (font) => {
  // 创建字体  TextGeometry(text内容, 字体配置)
  const textGeometry = new TextGeometry("小新", {
    font, // 字体文件
    size: 1, // 字体大小
    depth: 0.3, // 字体厚度
    // bevelEnabled: true, // 开启斜角
    // bevelSize: 0.05, // 斜角大小
    // bevelThickness: 0.05, // 斜角厚度
    // bevelOffset: 0, // 斜角偏移量
    // bevelSegments: 10, // 斜角段数
  });

  // 创建材质
  const textMaterial = new THREE.MeshLambertMaterial({
    color: "red",
  });

  // 创建网格
  const textMesh = new THREE.Mesh(textGeometry, textMaterial);

  // 计算字体位置
  // 开启boundingBox
  textGeometry.computeBoundingBox();
  // 获取字体的长度, 因为boundingBox耗费性能，所以默认是不开启的，需要手动使用 computeBoundingBox() 开启
  const textength = textGeometry.boundingBox!.max.x;
  // 调整位置
  textMesh.position.x = -textength / 2;

  // 将网格添加到场景
  scense.add(textMesh);

  // 字体倒影
  const shadowTextMesh = textMesh.clone();

  // 获取字体厚度
  const texts = textGeometry.boundingBox!.max.z;

  // 设置倒影位置
  shadowTextMesh.position.set(-textength / 2, -0.6, texts);

  // 将网格倒转
  shadowTextMesh.rotation.x = Math.PI;

  // 将倒影添加到场景
  scense.add(shadowTextMesh);
});

//--------------------------------end-----------------------

// -----------------------------粒子效果--------------------
// 定义多边形，为什么使用 BufferGeometry ，是因为 BufferGeometry 所有东西都可以自定义，大小、数量、xyz等等
// 这个效果最好，因为使用的是 GPU内存
const bufferGeometry = new THREE.BufferGeometry();
// 粒子的数量
const count = 10000;
// 定义顶点, 3个为一组, 也就是xyz的点
const vertices = new Float32Array(count * 3);
// 给位置
for (let index = 0; index < count * 3; index++) {
  // 为什么要 - 0.5 ，是因为会都聚集在一起，没有居中, 具体情况自己调这个数
  vertices[index] = (Math.random() - 0.5) * 30;
}
console.log(vertices);

// 设置顶点位置
bufferGeometry.setAttribute("position", new THREE.BufferAttribute(vertices, 3));

// 创建粒子点材质
const particleMaterial = new THREE.PointsMaterial({
  color: "pink", // 颜色
  size: 0.05, // 大小
  sizeAttenuation: true, // 是否衰减
  transparent: true, // 是否透明
});

// 创建粒子网格
const particleMesh = new THREE.Points(bufferGeometry, particleMaterial);

// 将粒子网格添加到场景
scense.add(particleMesh);

// ----------------------------end-------------------------

// 创建渲染器
const render = new THREE.WebGLRenderer({
  canvas: document.querySelector("#canvas") as HTMLCanvasElement, // 目标canvas
  antialias: true, // 抗锯齿
});
// 自适应像素
render.setPixelRatio(window.devicePixelRatio);
// 设置渲染器大小
render.setSize(window.innerWidth, window.innerHeight);
// 将场景和相机添加到渲染器中并渲染
render.render(scense, camera);

// 创建控制器
const controls = new OrbitControls(camera, render.domElement);

// 轮询动画函数
const animate = () => {
  // 和定时器一样，但是不会卡死，因为 requestAnimationFrame 是按帧渲染，一帧(16.6666毫秒)渲染一次
  requestAnimationFrame(animate);
  // 让粒子动起来
  particleMesh.rotateY(0.01);
  particleMesh.rotateX(0.01);
  particleMesh.rotateZ(0.01);
  // 将场景和相机添加到渲染器中
  render.render(scense, camera);
  // 更新渲染器
  controls.update();
};
animate();
```
