---
outline: deep

prev:
  text: "性能优化"
  link: "/performance-optimization"
next:
  text: "自定义模型(线条-贴图-第三方模型)"
  link: "/threejs/02自定义模型(线条-贴图-第三方模型)"
---

## threejs

`threejs`是一个开源的 `JavaScript `库，用于创建 `3D` 场景。它提供了丰富的 `API` 和`工具`，帮助开发者快速构建复杂的 3D 应用程序。
`threejs` 的核心思想是通过 `WebGL` 渲染器来实现 3D 渲染，它支持多种渲染模式，包括 `Canvas`、`WebGL` 和 `SVG` 等。
`threejs` 的 API 简洁易用使得开发者可以轻松地创建和渲染 3D 内容。以下是`threejs`的一些关键特性：

1. 丰富的 `API`：`threejs` 提供了大量的 `API`，包括 `Mesh`、`Camera`、`Light`、`Material` 等，可以帮助开发者快速创建和渲染 3D 内容。
2. 多种渲染模式：`threejs` 支持多种渲染模式，包括 `Canvas`、`WebGL` 和 `SVG` 等，可以帮助开发者根据不同的需求选择合适的渲染模式。
3. 多平台支持：`threejs` 支持多种平台，包括浏览器、Node.js 和桌面应用程序等，可以帮助开发者在不同的环境中创建和渲染 3D 内容。
4. 多语言支持：`threejs` 支持多种语言，包括 JavaScript、TypeScript 和 C++ 等，可以帮助开发者根据不同的需求选择合适的编程语言。

## 安装

```sh
## three @types/three : threejs库和ts声明文件
npm i three @types/three vite
```

## 组成步骤

`scene场景必须放在首位`, `渲染必须放在最后`, 其他的顺序没什么讲究, `scene`、`渲染器`、`camera`是必须的

1. `场景(scene)`: `scene` 是一个 `THREE.Scene` 对象，用于存储所有 3D 对象, `必须放在首位`。
2. `几何体(物体)`: 也就是目标对象，比如立方体、球体、圆柱体等。包含以下:

- `立方体(BoxGeometry)`
- `球体(SphereGeometry)`
- `圆柱体(CylinderGeometry)`
- `平面(PlaneGeometry)`
- `圆锥体(ConeGeometry)`
- `原形平面(CircleGeometry)`
- `正四面体(TetrahedronGeometry)` 。

3. `材质(material)`: 材质是物体的外观，包括颜色、纹理、透明度等。`threejs` 提供了多种材质类型，包括:

- `基本材质(MeshBasicMaterial)`: 什么都没有，没光照
- `兰伯特材质(MeshLambertMaterial)`: 有光照
- `冯氏材质(MeshPhongMaterial)`: 有光照
- `卡通材质(MeshToonMaterial)`: 有光照
- `法线材质(MeshNormalMaterial)`: 有光照
- `深度材质(MeshDepthMaterial)`: 有光照
- `精灵材质(SpriteMaterial)`: 有光照

4. `网格(Mesh)`: 通过`几何体`和`材质`组合在一起，形成一个完整的 3D 对象。

- `线性网格(lineMesh)`
- `普通网格(Mesh)`
- `粒子网格(Points)`

5. `光源`: 也就是观察物体视觉的效果,包含:

- `环境光 (AmbientLight)`:环境光是一种均匀、无方向的光源，影响场景中的所有物体，模拟全局光照效果。它不会产生阴影。

- `点光源(PointLight)`: 点光源从一个点向四周发射光线，类似现实中的灯泡。光强会随距离衰减，可产生阴影。

- `聚光灯(SpotLight)`: 聚光灯从一个点向四周发射光线，类似现实中的灯泡。光强会随距离衰减，可产生阴影。

- `方向光(DirectionalLight)`:方向光模拟平行光源（如太阳光），光线从特定方向均匀照射，不随距离衰减。可产生阴影

- `半球光 (HemisphereLight)`: 半球光模拟天空和地面的双色光照，适合室外场景，提供柔和的自然光效果。不产生阴影。

- `区域光 (RectAreaLight)`: 区域光从矩形区域发出光线，模拟柔和的平面光源（如窗户或面板灯）。仅在 `WebGLRenderer` 中支持，且需要 `RectAreaLightUniformsLib`。

6. `相机(PerspectiveCamera)`: 相机是观察场景的工具，通过设置相机的属性（如 `fov`、`aspect`、`near`、`far`）来控制场景的渲染范围和比例。

7. `渲染器(WebGLRenderer)`: 渲染器是将 3D 对象渲染到屏幕上的工具，通过设置渲染器的属性（如 `antialias`、`alpha`、`preserveDrawingBuffer`）来控制渲染效果。

## 示例项目

1. 修改`package.json`启动命令，使用`vite`启动

```ts
{
  "name": "threejs",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "vite"
  },
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/three": "^0.178.0",
    "three": "^0.178.0",
    "vite": "^6.3.5"
  }
}

```

2. 在`~/code/first.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>threejs入门</title>
    <!-- <script type="module" src="./first.ts"></script> -->
    <script type="module" src="./firstTest.ts"></script>
  </head>
  <body>
    <div class="cantinar">
      <!-- <canvas class="firstCanvas"></canvas> -->
      <canvas id="testCanvas" width="300" height="300"></canvas>
      <div id="stats"></div>
    </div>
  </body>
</html>

<style>
  html,
  body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
  }
  .cantinar {
    width: 100vw;
    height: 100vh;
  }
</style>
```

3. `编写示例逻辑(~/code/first.ts)`

```ts
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
//stats 性能监控
import Stats from "three/addons/libs/stats.module.js";

// 创建一个场景
const scene = new THREE.Scene();

// 将全屏宽高设置到canva中
let width = 0;
let height = 0;
let dom: null | HTMLCanvasElement = null;

/**
 * 绘制函数
 */
const draw = () => {
  // 创建物体
  //立方体 BoxGeometry
  //圆柱体   CylinderGeometry
  //圆锥体  ConeGeometry
  //平面  PlaneGeometry
  //原形平面  CircleGeometry
  //正四面体 TetrahedronGeometry
  //球体 SphereGeometry
  const target = new THREE.SphereGeometry(30, 30, 30);

  // 光源
  // 环境光 (AmbientLight)
  // 点光源 (PointLight)
  // 聚光灯 (SpotLight)
  // 方向光 (DirectionalLight)
  // 半球光 (HemisphereLight)
  // 区域光 (RectAreaLight)
  const light = new THREE.DirectionalLight(0xffc0cb, 1);
  // 设置官员位置 (x,y,z)轴
  light.position.set(100, 100, 100);
  // 将光源添加到场景中
  scene.add(light);

  // 创建材质
  //图形学
  //兰伯特漫反射模型 常用于粗糙表面 四面八方扩散
  //冯氏光照模型-镜面高光技术 折射 冯氏光照模型是基于兰伯特漫反射模型实现的
  //所以说冯氏光照模型可以用漫反射的参数
  // 材质:
  //基础材质 MeshBasicMaterial 什么都没有 光照
  //兰伯特材质 MeshLambertMaterial 有光照
  //冯氏材质 MeshPhongMaterial 有光照
  //卡通材质 MeshToonMaterial 有光照
  //法线材质 MeshNormalMaterial 有光照
  //深度材质 MeshDepthMaterial 有光照
  //精灵材质 SpriteMaterial 有光照
  const material = new THREE.MeshLambertMaterial({
    // emissiveIntensity: 1, // 发射强度
    // emissive: 0x000000, // 发射颜色
    color: 0x0000ff,
    // wireframe: true, //线框
    // specular: 0x1188ff, //高光颜色
    // shininess: 100, //光泽度
  });

  // 创建网格
  // 将物体和材质添加到网格中
  const mesh = new THREE.Mesh(target, material);
  mesh.position.set(10, 60, 0);
  // 将网格添加到场景中
  scene.add(mesh);

  // 添加辅助坐标轴(仅开发使用)
  // const axesHelper = new THREE.AxesHelper(200)
  // scene.add(axesHelper)

  // 创建相机
  const camera = new THREE.PerspectiveCamera(45, width / height);
  // 设置相机位置
  // xyz轴
  camera.position.set(200, 200, 200);
  // 将相机视角向物体
  camera.lookAt(mesh.position);
  // 将相机添加到场景中
  scene.add(camera);

  // 创建渲染器
  const render = new THREE.WebGLRenderer({
    canvas: dom!,
    antialias: true, //抗锯齿
    alpha: true, //透明背景
    // logarithmicDepthBuffer: true, //深度缓冲区
    // stencil: true, // stencil缓冲区
    // preserveDrawingBuffer: true, //保存绘图缓冲区
    // powerPreference: 'high-performance', //性能
  });
  // 设置渲染器大小, 一般是canvas的宽高
  render.setSize(width, height);

  // 创建性能监视器
  const stats = new Stats();
  // 在文档加入监视器
  document.body.appendChild(stats.dom);

  // 创建控制器
  const controls = new OrbitControls(camera, render.domElement);

  // 开始渲染
  const animate = () => {
    requestAnimationFrame(animate); // 代替计时器，RAF 稳定60帧
    // 将场景和相机添加到渲染器中
    render.render(scene, camera);
    // 网格旋转
    // mesh.rotation.x += 0.01
    // mesh.rotation.y += 0.01
    // 给网格的材质颜色设置为蓝色
    // mesh.material.color.set(0x0000FF)
    controls.update();
    stats.update();
  };
  animate();
};

/**
 * 监听窗口大小变化事件
 */
const resize = function () {
  const body = document.body;
  dom = document.querySelector(".firstCanvas") as HTMLCanvasElement;
  if (dom) {
    dom.width = width = body.clientWidth;
    dom.height = height = body.clientHeight;
    draw();
  }
};
window.addEventListener("resize", resize);
resize();
```

4. `另外一个例子我也贴上去(~/code/firstTest.ts)`

```ts
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
//stats 性能监控
import Stats from "three/addons/libs/stats.module.js";

type Target =
  | THREE.BoxGeometry
  | THREE.CylinderGeometry
  | THREE.ConeGeometry
  | THREE.PlaneGeometry
  | THREE.CircleGeometry
  | THREE.TetrahedronGeometry
  | THREE.SphereGeometry;
interface CreateTarget {
  scene: THREE.Scene;
  createTarget: Target | (() => Target);
  materialOptions: {
    type:
      | "MeshBasicMaterial"
      | "MeshLambertMaterial"
      | "MeshPhongMaterial"
      | "MeshNormalMaterial"
      | "MeshDepthMaterial"
      | "SpriteMaterial";
    props: any;
  };
  meshPosition: {
    x: number;
    y: number;
    z: number;
  };
  /**
   *
   * @param scene 场景
   * @param mesh 网格
   * @param target 目标物体
   * @returns
   */
  callback: (scene: THREE.Scene, mesh: THREE.Mesh, target: Target) => any;
}

/**
 * 创建物体
 * @param scene 场景
 * @param createTarget 回调函数，返回一个物体实例
 * @param material 材质类型和属性
 * @param meshPosition 物体位置
 * @param callback 回调函数
 * @returns 无
 */
const createTarget = (
  scene: CreateTarget["scene"],
  createTarget: CreateTarget["createTarget"],
  materialOptions: CreateTarget["materialOptions"],
  meshPosition: CreateTarget["meshPosition"],
  callback?: CreateTarget["callback"]
): { target: Target; mesh: THREE.Mesh } => {
  // 创建物体
  const target =
    createTarget instanceof Function ? createTarget() : createTarget;
  // 创建材质
  const material = new THREE[materialOptions.type](materialOptions.props);
  // 创建网格
  const mesh = new THREE.Mesh(target, material);
  // 设置网格位置
  mesh.position.set(meshPosition.x, meshPosition.y, meshPosition.z);

  // 如果有其他操作
  callback && callback(scene, mesh, target);

  // 将网格添加到场景中
  scene.add(mesh);

  return { target, mesh };
};

/**
 * 构建
 */
const build = (dom: HTMLCanvasElement) => {
  // 创建一个场景
  const scene = new THREE.Scene();

  // 创建相机
  const camera = new THREE.PerspectiveCamera(50, dom.width / dom.height);
  // 设置相机位置
  camera.position.set(0, 0, 100);
  // 将相机视角向物体
  camera.lookAt(scene.position);
  // 将相机添加到场景中
  scene.add(camera);

  // 创建渲染器
  const render = new THREE.WebGLRenderer({
    canvas: dom,
    antialias: true, // 抗锯齿,
    alpha: false, // 透明背景
  });
  // 设置渲染器大小
  render.setSize(dom.width, dom.height);

  // 创建性能监视器
  const stats = new Stats();
  // 在文档中加入监视器
  document.body.appendChild(stats.dom);

  // 创建控制器
  const controls = new OrbitControls(camera, render.domElement);

  // 创建物体
  // 头
  createTarget(
    scene,
    () => new THREE.SphereGeometry(12, 32, 32),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0x0000ff,
        wireframe: false,
      },
    },
    { x: 0, y: 25, z: 0 },
    (scene, mesh, target) => {}
  );
  // 眼睛
  createTarget(
    scene,
    () => new THREE.SphereGeometry(3, 32, 32),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xffffff,
      },
    },
    { x: -4, y: 27, z: 10 }
  );
  createTarget(
    scene,
    () => new THREE.SphereGeometry(3, 32, 32),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xffffff,
      },
    },
    { x: 4, y: 27, z: 10 }
  );

  // 鼻子
  createTarget(
    scene,
    () => new THREE.SphereGeometry(2, 32, 32),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xff0000,
      },
    },
    { x: 0, y: 21, z: 12 }
  );

  // 嘴巴
  createTarget(
    scene,
    () => new THREE.CircleGeometry(4, 32, Math.PI, (2 * Math.PI) / 2), // 半圆,
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xff0000,
      },
    },
    { x: 0, y: 18, z: 10 }
  );

  // 身体
  createTarget(
    scene,
    () => new THREE.CylinderGeometry(12, 12, 32, 32),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0x0000ff,
        transparent: false, // 启用透明
        opacity: 0.5, // 透明度（0.0 完全透明，1.0 完全不透明）
      },
    },
    {
      x: 0,
      y: -3,
      z: 0,
    }
  );

  // 左手
  const { mesh: leftHandMesh } = createTarget(
    scene,
    () => new THREE.CylinderGeometry(4, 4, 20, 20),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0x0000ff,
        transparent: false, // 启用透明
        opacity: 0.5, // 透明度（0.0 完全透明，1.0 完全不透明）
      },
    },
    {
      x: -17,
      y: 0,
      z: 0,
    }
  );
  // 旋转角度
  leftHandMesh.rotation.z = -20;

  // 右手
  const { mesh: rightMesh } = createTarget(
    scene,
    () => new THREE.CylinderGeometry(4, 4, 20, 20),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0x0000ff,
        transparent: false, // 启用透明
        opacity: 0.5, // 透明度（0.0 完全透明，1.0 完全不透明）
      },
    },
    {
      x: 17,
      y: 0,
      z: 0,
    }
  );
  // 旋转角度
  rightMesh.rotation.z = 20;

  // 手腕
  createTarget(
    scene,
    () => new THREE.SphereGeometry(4, 20, 20),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xffffff,
      },
    },
    { x: -28, y: -5, z: 0 }
  );
  createTarget(
    scene,
    () => new THREE.SphereGeometry(4, 20, 20),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xffffff,
      },
    },
    { x: 28, y: -5, z: 0 }
  );

  // 腿
  createTarget(
    scene,
    () => new THREE.CylinderGeometry(3, 3, 10, 10),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0x0000ff,
        transparent: false, // 启用透明
        opacity: 0.5, // 透明度（0.0 完全透明，1.0 完全不透明）
      },
    },
    {
      x: -5,
      y: -23,
      z: 0,
    }
  );
  createTarget(
    scene,
    () => new THREE.CylinderGeometry(3, 3, 10, 10),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0x0000ff,
        transparent: false, // 启用透明
        opacity: 0.5, // 透明度（0.0 完全透明，1.0 完全不透明）
      },
    },
    {
      x: 5,
      y: -23,
      z: 0,
    }
  );

  // 口袋
  createTarget(
    scene,
    () => new THREE.CircleGeometry(6, 32, Math.PI, (2 * Math.PI) / 2), // 半圆,
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xff0000,
      },
    },
    { x: 0, y: -6, z: 12 }
  );

  // 脚
  createTarget(
    scene,
    () => new THREE.SphereGeometry(4, 20, 20),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xffffff,
      },
    },
    { x: 5, y: -30, z: 0 }
  );
  createTarget(
    scene,
    () => new THREE.SphereGeometry(4, 20, 20),
    {
      type: "MeshBasicMaterial",
      props: {
        color: 0xffffff,
      },
    },
    { x: -5, y: -30, z: 0 }
  );

  // 开始渲染
  const animate = () => {
    requestAnimationFrame(animate); // 代替计时器，RAF 稳定60帧
    // 将场景和相机添加到渲染器中
    render.render(scene, camera);
    controls.update();
    stats.update();
  };
  animate();
};

/**
 * 监听窗口大小变化事件
 */
const resize = () => {
  const body = document.body as HTMLBodyElement;
  const dom = document.querySelector("#testCanvas") as HTMLCanvasElement;
  dom.width = body.clientWidth;
  dom.height = body.clientHeight;
  build(dom);
};

window.addEventListener("resize", resize);
resize();
```

5. 启动

```sh
# 如无特殊配置的情况下， 访问http://localhost:5173/code/first.html
npm run dev
```
