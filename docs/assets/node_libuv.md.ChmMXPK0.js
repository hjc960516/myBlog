import{_ as s,c as i,o as a,a3 as n,ac as l}from"./chunks/framework.CPUa57fC.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep","prev":{"text":"oss云存储","link":"/node/oss"},"next":{"text":"fastify框架","link":"/node/fastify"}},"headers":[],"relativePath":"node/libuv.md","filePath":"node/libuv.md"}'),e={name:"node/libuv.md"},p=n('<h2 id="libuv" tabindex="-1">libuv <a class="header-anchor" href="#libuv" aria-label="Permalink to &quot;libuv&quot;">​</a></h2><p>在 Node.js 中，libuv 是作为其事件循环和异步 I/O 的核心组件而存在的。Node.js 是构建在 libuv 之上的，它利用 libuv 来处理底层的异步操作，如文件 I/O、网络通信和定时器等</p><h3 id="libuv-在-js-中的作用" tabindex="-1">libuv 在 js 中的作用 <a class="header-anchor" href="#libuv-在-js-中的作用" aria-label="Permalink to &quot;libuv 在 js 中的作用&quot;">​</a></h3><ol><li><code>事件循环（Event Loop）</code>：libuv 实现了 Node.js 的事件循环机制，负责管理事件的调度和执行。 事件循环是 Node.js 的核心机制，它使得 Node.js 能够以非阻塞的方式处理大量并发操作</li><li><code>异步I/O操作</code>：libuv 提供了一组异步 I/O 的 API，用于处理文件、网络和其他 I/O 操作。这些 API 能够在后台进行操作，而无需阻塞主线程，从而实现高效的并发处理</li><li><code>网络通信</code>：libuv 封装了底层的网络通信功能，包括 TCP 和 UDP 套接字的创建、绑定、监听和连接等操作。它提供了高级的网络接口，方便开发者构建基于网络的应用程序</li><li><code>定时器和事件触发</code>：libuv 提供了定时器相关的 API，可以创建和管理定时器，以及在指定时间间隔后触发相应的回调函数。这对于处理定时任务和调度是非常有用的</li><li><code>跨平台支持</code>：libuv 实现了对不同操作系统的抽象封装，使得 Node.js 能够在不同的平台上运行，并保持一致的行为和性能</li></ol><h2 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h2><p>在 Nodejs 中，事件循环分为<code> 6 个阶段</code>。每个阶段都有一个任务队列, 详情请看 <a href="https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick" target="_blank" rel="noreferrer">官方的事件循环机制解析</a><img src="'+l+`" alt="libuv事件循环流程图"></p><h3 id="宏任务-事件循环阶段" tabindex="-1">宏任务(事件循环阶段) <a class="header-anchor" href="#宏任务-事件循环阶段" aria-label="Permalink to &quot;宏任务(事件循环阶段)&quot;">​</a></h3><ol><li><code>timers</code>: 执行 setTimeout 和 setInterval 的回调</li><li><code>pending callbacks</code>: 执行推迟的回调如 IO，计时器(node 内部执行)</li><li><code>idle，prepare</code>: 空闲状态 nodejs 内部使用无需关心(node 内部执行)</li><li><code>poll</code>: 执行与 I/O 相关的回调（除了关闭回调、计时器调度的回调和 setImmediate 之外，几乎所有回调都执行） 例如 fs 的回调 http 回调</li><li><code>check</code>: 执行 setImmediate 的回调</li><li><code>close callback</code>: 执行例如 socket.on(&#39;close&#39;, ...) 关闭的回调</li></ol><h3 id="微任务" tabindex="-1">微任务 <a class="header-anchor" href="#微任务" aria-label="Permalink to &quot;微任务&quot;">​</a></h3><ol><li>process.nextTick</li><li>promise</li></ol><h3 id="不准确性" tabindex="-1">不准确性 <a class="header-anchor" href="#不准确性" aria-label="Permalink to &quot;不准确性&quot;">​</a></h3><p>在事件循环的每个循环迭代中，libuv 会调用<code>uv__update_time函数</code>来更新当前的时间戳。 这个时间戳通常用于计算定时器的超时时间和检查事件的发生时间，而 <code>setImmediate</code>，则是把回调函数直接插入队列，所以执行效率比较高。 所以就会造成顺序不稳定的一个原因</p><h2 id="源码解析" tabindex="-1">源码解析 <a class="header-anchor" href="#源码解析" aria-label="Permalink to &quot;源码解析&quot;">​</a></h2><p><code>git上的libuv源码路径：libuv/src/unix/core.c</code></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv_run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uv_loop_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, uv_run_mode </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timeout;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> can_sleep;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv__loop_alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //检查事件循环是否活跃</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //如果事件循环不活跃，直接返回</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__update_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //调用这个函数更新时间戳去检查计时器 超时时间 耗时</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* Maintain backwards compatibility by processing timers before entering the</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * while loop for UV_RUN_DEFAULT. Otherwise timers only need to be executed</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * once, which should be done after polling in order to maintain proper</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   * execution order of the conceptual event loop. */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV_RUN_DEFAULT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loop-&gt;stop_flag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__update_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //更新时间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_timers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //执行定时器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loop-&gt;stop_flag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    can_sleep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        uv__queue_empty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop-&gt;pending_queue) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        uv__queue_empty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop-&gt;idle_handles);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_pending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //执行事件队列中的事件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_idle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //执行空闲队列中的事件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_prepare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //执行预备队列中的事件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV_RUN_ONCE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> can_sleep) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV_RUN_DEFAULT)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv__backend_timeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__metrics_inc_loop_count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__io_poll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop, timeout);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //执行事件循环</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Process immediate callbacks (e.g. write_cb) a small fixed number of</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * times to avoid loop starvation.*/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uv__queue_empty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">loop-&gt;pending_queue); r</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      uv__run_pending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* Run one final update on the provider_idle_time in case uv__io_poll</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * returned because the timeout expired, but no events were received. This</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * call will be ignored if the provider_entry_time was either never set (if</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * the timeout == 0) or was already updated b/c an event was received.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__metrics_update_idle_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //更新空闲时间</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_check</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //执行检查队列中的事件 setImmediate</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_closing_handles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //执行关闭队列中的事件</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__update_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //更新时间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_timers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //执行定时器</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv__loop_alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV_RUN_ONCE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> UV_RUN_NOWAIT)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><h2 id="uv-update-time-函数实现" tabindex="-1">uv__update_time 函数实现 <a class="header-anchor" href="#uv-update-time-函数实现" aria-label="Permalink to &quot;uv\\_\\_update_time 函数实现&quot;">​</a></h2><p><code>git上的libuv源码路径：libuv/src/unix/internal.c</code></p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UV_UNUSED</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv__update_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">uv_loop_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* Use a fast time source if available.  We only need millisecond precision.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这个函数通过调用 \`gethrtime\` 获取系统当前时间，精度非常高，单位是纳秒（ns），</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 1 纳秒等于十亿分之一秒。除 \`1000000\` 后的时间单位为 毫秒（ms）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  loop-&gt;time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv__hrtime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UV_CLOCK_FAST) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h2><div class="warning custom-block"><p class="custom-block-title">注意事项</p><p>在 <code>nodejs 不同版本\`\`微任务</code>执行策略不同, <code>低版本</code> <code>nextTick</code> 优先于 <code>Promise</code>, 高版本则相反</p></div>`,20),h=[p];function t(k,d,r,o,E,c){return a(),i("div",null,h)}const u=s(e,[["render",t]]);export{y as __pageData,u as default};
