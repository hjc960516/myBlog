import{_ as s,c as a,o as e,a3 as i}from"./chunks/framework.F_gBKVsg.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"outline":"deep","prev":{"text":"发布订阅和事务","link":"/node/redis/publish_subscribeAndTransaction"},"next":{"text":"ioredis","link":"/node/redis/ioredis"}},"headers":[],"relativePath":"node/redis/persistence_masterSlave.md","filePath":"node/redis/persistence_masterSlave.md"}'),n={name:"node/redis/persistence_masterSlave.md"},l=i(`<h2 id="持久化" tabindex="-1">持久化 <a class="header-anchor" href="#持久化" aria-label="Permalink to &quot;持久化&quot;">​</a></h2><h3 id="rdb-redis-database-持久化" tabindex="-1">RDB（Redis Database）持久化 <a class="header-anchor" href="#rdb-redis-database-持久化" aria-label="Permalink to &quot;RDB（Redis Database）持久化&quot;">​</a></h3><p>RDB 是一种快照的形式，它会将内存中的数据定期保存到磁盘上。 可以通过配置 Redis 服务器，设置自动触发 RDB 快照的条件，比如在指定的时间间隔内，或者在指定的写操作次数达到一定阈值时进行快照保存。 RDB 持久化生成的快照文件是一个二进制文件，包含了 Redis 数据的完整状态。在恢复数据时，可以通过加载快照文件将数据重新加载到内存中</p><h4 id="rdb-实现" tabindex="-1">RDB 实现 <a class="header-anchor" href="#rdb-实现" aria-label="Permalink to &quot;RDB 实现&quot;">​</a></h4><ul><li><code>windows</code>: 打开安装包的<code>redis.conf</code>配置文件</li><li><code>mac</code>: 如果是<code>brew</code>安装的, 配置文件路径是<code>/usr/local/etc/redis.conf</code></li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><p>在<code>mac</code>进行快照的时候，<code>dump.rdb</code>快照文件不在<code>/usr/local/Cellar/redis</code>这个下载文件路径里面 ,而是在<code>/usr/local/var/db/redis</code></p></div><div class="language-conf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">conf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 在配置文件中加入, 也就是在设置的时间内，达到目标次数，会进行一次快照存进dump.rdb文件</span></span>
<span class="line"><span># 弊端是: 如果设置了一个小时存一次，但是在一个半小时的时候服务器宕机了，那么会丢失半个小时的数据</span></span>
<span class="line"><span># rdb持久化一般用来做数据备份</span></span>
<span class="line"><span># save 时间(秒) 次数</span></span>
<span class="line"><span>save 3600 10 # 一个小时变化10次会进行一次快照</span></span></code></pre></div><ul><li><code>也可以手动进行快照</code></li></ul><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 在redis启动服务的命令行中手动进行rdb快照</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">save</span></span></code></pre></div><h3 id="aof-append-only-file-持久化" tabindex="-1">AOF（Append-Only File）持久化 <a class="header-anchor" href="#aof-append-only-file-持久化" aria-label="Permalink to &quot;AOF（Append-Only File）持久化&quot;">​</a></h3><p>AOF 持久化记录了 Redis 服务器执行的所有写操作命令，在文件中以追加的方式保存。 当 Redis 需要重启时，可以重新执行 AOF 文件中保存的命令，以重新构建数据集。相比于 RDB 持久化，AOF 持久化提供了更好的数据恢复保证，因为它记录了每个写操作，而不是快照的形式。 然而，AOF 文件相对于 RDB 文件更大，恢复数据的速度可能会比较慢</p><h4 id="aof-实现" tabindex="-1">AOF 实现 <a class="header-anchor" href="#aof-实现" aria-label="Permalink to &quot;AOF 实现&quot;">​</a></h4><p>在<code>redis.conf</code>配置文件中，把<code>appendonly</code>配置项改为<code>true</code>即可</p><h2 id="主从复制" tabindex="-1">主从复制 <a class="header-anchor" href="#主从复制" aria-label="Permalink to &quot;主从复制&quot;">​</a></h2><p>Redis 主从复制是一种数据复制和同步机制，其中一个 Redis 服务器（称为主服务器）将其数据复制到一个或多个其他 Redis 服务器（称为从服务器）。主从复制提供了数据冗余备份、读写分离和故障恢复等功能</p><h2 id="工作流程" tabindex="-1">工作流程 <a class="header-anchor" href="#工作流程" aria-label="Permalink to &quot;工作流程&quot;">​</a></h2><ol><li><code>配置主服务器</code>：在<code>主服务器</code>上，你需要在<code>配置文件</code>中启用<code>主从复制</code>并<code>指定从服务器的IP地址和端口号</code>。你可以使用<code>replicaof</code>配置选项或<code>slaveof</code>配置选项来指定从服务器</li><li><code>连接从服务器</code>：从服务器连接到主服务器并发送复制请求。从服务器通过发送<code>SYNC</code>命令请求进行全量复制或通过发送<code>PSYNC</code>命令请求进行部分复制（增量复制）</li><li><code>全量复制（SYNC）</code>：如果从服务器是第一次连接或无法执行部分复制，主服务器将执行全量复制。 在全量复制期间，主服务器将快<code>照文件（RDB文件）</code>发送给从服务器，从服务器将接收并加载该文件以完全复制主服务器的数据</li><li><code>部分复制（PSYNC）</code>：如果从服务器已经执行过全量复制并建立了复制断点，主服务器将执行部分复制。 在部分复制期间，主服务器将发送增量复制流（replication stream）给从服务器，从服务器将接收并应用该流以保持与主服务器的同步</li><li><code>复制持久化</code>：从服务器接收到数据后，会将其保存在<code>本地磁盘</code>上，以便在重启后仍然保持数据的一致性</li><li><code>同步延迟</code>：从服务器的复制是<code>异步</code>的，因此存在复制延迟。延迟取决于<code>网络延迟</code>、<code>主服务器的负载</code>和<code>从服务器的性能</code>等因素</li><li><code>读写分离</code>：一旦建立了主从复制关系，从服务器可以接收读操作。这使得可以将读流量从主服务器分散到从服务器上，从而减轻主服务器的负载</li><li><code>故障恢复</code>：如果主服务器发生故障，可以将一个从服务器提升为新的主服务器，以继续提供服务。当主服务器恢复时，它可以作为从服务器连接到新的主服务器，继续进行数据复制</li></ol><h3 id="开启主服务器" tabindex="-1">开启主服务器 <a class="header-anchor" href="#开启主服务器" aria-label="Permalink to &quot;开启主服务器&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 默认端口是6379</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-server</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 进入redis</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-cli</span></span></code></pre></div><h3 id="新建从服务器配置文件" tabindex="-1">新建从服务器配置文件 <a class="header-anchor" href="#新建从服务器配置文件" aria-label="Permalink to &quot;新建从服务器配置文件&quot;">​</a></h3><div class="language-conf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">conf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># redis-6380.conf</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#ip地址 如果是mac电脑在 地址后面添加 \`::1\`</span></span>
<span class="line"><span>bind 127.0.0.1</span></span>
<span class="line"><span>#端口号</span></span>
<span class="line"><span>port 6380</span></span>
<span class="line"><span>#守护线程静默运行</span></span>
<span class="line"><span>daemonize yes</span></span>
<span class="line"><span>#指定主服务器</span></span>
<span class="line"><span>replicaof 127.0.0.1 6379</span></span></code></pre></div><h3 id="启动从服务器" tabindex="-1">启动从服务器 <a class="header-anchor" href="#启动从服务器" aria-label="Permalink to &quot;启动从服务器&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 配置文件路径</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 开启端口为6380的redis</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-cli</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6380</span></span></code></pre></div><h3 id="测试" tabindex="-1">测试 <a class="header-anchor" href="#测试" aria-label="Permalink to &quot;测试&quot;">​</a></h3><p>主服务器输入数据</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> age</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><p>从服务器</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 得到的数据是 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> age</span></span></code></pre></div>`,28),d=[l];function p(t,o,c,h,r,k){return e(),a("div",null,d)}const g=s(n,[["render",p]]);export{u as __pageData,g as default};
