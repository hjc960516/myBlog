## bcrypt 加密

是一个加密库，[文档](https://www.npmjs.com/package/bcrypt)

### 安装

```sh
## bcrypt: 加密库 @types/bcrypt: 库的类型文件
npm install bcrypt @types/bcrypt
```

## jwt 验证

`token`验证的一个库,[文档](https://www.npmjs.com/package/jsonwebtoken)

### 安装

```sh
npm install jsonwebtoken @types/jsonwebtoken --save

```

## 前后端例子

使用`bcrypt`加密密码,使用`jwt`验证`token`例子

### 前端

#### types 文件

```ts
import { z } from "zod";

export const userSchema = z.object({
  email: z.string().email({ message: "请输入正确的邮箱" }),
  password: z.string().min(6, "密码不能少于6位数").max(100),
});

export type User = z.infer<typeof userSchema>;
```

#### 注册页面

```vue
<template>
  <div>
    <div class="text-red-700 text-center">注册页</div>
    <div class="text-xs text-red-700" v-if="message">{{ message }}</div>
    <div>
      <form>
        <CustomVeeValidate name="email" label="账号" placeholder="请输入账号" />
        <CustomVeeValidate
          name="password"
          label="密码"
          placeholder="请输入密码"
        />
        <van-button type="primary" block @click="register">{{
          isSubmitting ? "loading..." : "注册"
        }}</van-button>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useForm } from "vee-validate";
import { toTypedSchema } from "@vee-validate/zod";
import { userSchema } from "./types";
const { values, errors, handleSubmit, isSubmitting } = useForm({
  validationSchema: toTypedSchema(userSchema),
});

const message = ref();
watch(
  () => values,
  () => {
    if (message.value) {
      message.value = "";
    }
  },
  {
    deep: true,
  }
);
const register = handleSubmit(async () => {
  try {
    const res = await $fetch("/api/bcryptAndJWT/register", {
      method: "POST",
      body: values,
    });
    message.value = res.message;
  } catch (error) {
    message.value = error.data.message;
  }
});
</script>

<style scoped></style>
```

#### 登录页

```vue
<template>
  <div>
    <div class="text-red-700 text-center">登录页</div>
    <div class="text-xs text-red-700" v-if="message">{{ message }}</div>
    <div>
      <form>
        <CustomVeeValidate name="email" label="账号" placeholder="请输入账号" />
        <CustomVeeValidate
          name="password"
          label="密码"
          placeholder="请输入密码"
        />
        <van-button type="primary" block @click="login">{{
          isSubmitting ? "loading..." : "登录"
        }}</van-button>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useForm } from "vee-validate";
import { toTypedSchema } from "@vee-validate/zod";
import { userSchema } from "./types";
const { values, errors, handleSubmit, isSubmitting } = useForm({
  validationSchema: toTypedSchema(userSchema),
});

const message = ref();
watch(
  () => values,
  () => {
    if (message.value) {
      message.value = "";
    }
  },
  {
    deep: true,
  }
);

const login = handleSubmit(async () => {
  try {
    const res = await $fetch("/api/bcryptAndJWT/login", {
      method: "POST",
      body: values,
    });
    message.value = res.message;
  } catch (error) {
    message.value = error.data.message;
  }
});
</script>

<style scoped></style>
```

### 后端

使用的是`前面提到的mongoos`, 具体操作看之前的`modules`篇章

#### 建表

在`/server/models/bcryptAndJWT/register.ts`

```ts
import { defineMongooseModel } from "#nuxt/mongoose";
import { User } from "~/pages/bcryptAndJWT/types";

// 定义模型(建表)
export const bcryptAndJWTSchema = defineMongooseModel<User>(
  "bcryptAndJWTSchema",
  {
    email: {
      type: String,
      required: true,
      unique: true,
    },
    password: {
      type: String,
      required: true,
    },
  }
);
```

#### 注册接口(register.post.ts)

```ts
import { defineMongooseModel } from "#nuxt/mongoose";
import { User } from "~/pages/bcryptAndJWT/types";

// 定义模型(建表)
export const bcryptAndJWTSchema = defineMongooseModel<User>(
  "bcryptAndJWTSchema",
  {
    email: {
      type: String,
      required: true,
      unique: true,
    },
    password: {
      type: String,
      required: true,
    },
  }
);
```

#### 登录接口(login.post.ts)

```ts
import type { User } from "~/pages/bcryptAndJWT/types";
import { bcryptAndJWTSchema } from "~/server/models/bcryptAndJWT/register";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";

export default defineEventHandler(async (event) => {
  const body = await readBody(event);
  const { email, password }: User = body;
  // 查询是否有用户
  const hasUser = await bcryptAndJWTSchema.findOne({ email }).exec();
  if (!hasUser) {
    throw createError({
      statusCode: 404,
      statusMessage: "用户不存在或者密码错误",
    });
  }
  // 对比密码
  const isPass = await bcrypt.compare(password, hasUser.password);
  if (!isPass) {
    throw createError({
      statusCode: 400,
      statusMessage: "用户不存在或者密码错误",
    });
  }

  // jwttoken生成， 比较敏感的信息可以放在环境.env文件中
  // payload: 载荷，也就是加密的数据
  // secretOrPrivateKey: 密钥
  // options: 选项
  // jwt.sign(payload, secretOrPrivateKey, [options, callback])
  const token = jwt.sign(
    {
      email: hasUser.email,
      id: hasUser._id,
    },
    "secretOrPrivateKey",
    {
      expiresIn: "1h", // 过期时间, 默认是秒，1h：1小时
      algorithm: "HS256", // 加密算法
    }
  );

  // 将token以cookie的形式返回给前端
  // setCookie(event,key名，值，配置)
  setCookie(event, "token", token, {
    // httpOnly: true, // 前端不能访问
    // secure: true, // 只有在https协议下才可以访问
    maxAge: 60 * 60, // 过期时间, 单位秒， 需要和token过期时间保持一致
  });
  return {
    code: 200,
    message: "登录成功",
    data: {
      token: token,
      ...hasUser.toJSON({
        // 删除密码信息
        transform: (doc, ret) => {
          delete ret.password;
        },
      }),
    },
  };
});
```

#### 验证 token 中间件

在`/server/middleware/jwt.ts`

```ts
import jwt from "jsonwebtoken";
export default defineEventHandler(async (event) => {
  // 特定路由验证, 如果不是特定路由，直接返回
  const isPass = ["/api/bcryptAndJWT/testjwt"];
  if (!isPass.includes(event.path)) {
    return;
  }
  // 就是你setCookie设置的key名取出
  const token = getCookie(event, "token");

  if (!token) {
    throw createError({
      statusCode: 401,
      statusMessage: "未授权",
    });
  }
  try {
    // 解密token
    const userdata = jwt.verify(token, "secretOrPrivateKey");
    // 将信息保存在redis或者共享接口的event中
    event.context.user = userdata;
  } catch (error) {
    // 删除cookie
    deleteCookie(event, "token");
    // 删除event.context.user
    delete event.context.user;
    throw createError({
      statusCode: 400,
      statusMessage: "token过期",
    });
  }
});
```

#### 测试接口(testjwt.ts)

需要一个接口进行验证`token`是否通过

```ts
export default defineEventHandler(async (event) => {
  // 验证token
  const user = event.context.user;
  if (!user) {
    throw createError({
      statusCode: 401,
      statusMessage: "未授权",
    });
  }
  return {
    code: 0,
    msg: "获取用户信息成功",
    data: user,
  };
});
```
