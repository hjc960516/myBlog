## 构建和部署

[官网地址](https://nuxt.com/docs/4.x/getting-started/deployment)<br />
有好几种构建和部署方式，下面是官方提供的几种方式：

1. `node.js:server`

- 没有特殊配置时，会默认输出格式
- 按需加载，加速冷启动
- 适配任何的`nodejs`版本`(18+以上)`
- 内置的`cluster mode(多进程模式)`

2. `static hosting静态文件部署`

- `ssg(static site generation)模式`: 在构建以后自动生成所有相关路由的静态文件`(通过 nitro 爬虫完成)`,有多少个路由就有多少个静态页面，有利于`seo`和`加载速度`

- `client-side only rendering (ssr:false)`: `spa应用`,只有一个入口文件，HTML 中只有一个`<div class="__nuxt"></div>>`DOM 节点，所有的内容都通过`js`进行加载

```ts
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: false,
});
```

3. 部署到第三方平台

[所有第三方平台预览地址](https://nuxt.com/deploy)

## 构建例子

使用的是`nodejs-server`方法进行构建

### 执行打包命令

打包完以后, 有`public`和`server`两个，`public`是`前端(客户端)`的静态文件, `server`是`后端(服务器)`的静态文件

```sh
npm run build
```

### 执行预览命令

使用`node`环境去执行打包后的文件`.output/server/index.mjs`文件, 需要`node20`版本以上，否则会无法读取到`.env`环境变量文件

```sh
## node20之前的版本
### 只能通过 变量名=变量值 这种方式设置环境变量

## node20++版本
### --env-file: 指定环境变量文件
### PORT: 设置端口号，默认是3000
### PORT: 设置主机地址，默认是`0.0.0.0`
# PORT=3000 HOST=0.0.0.0 node --env-file=.env .output/server/index.mjs
node --env-file=.env .output/server/index.mjs
```

### 编写脚本(`deploy.sh`)

需要先设置`免登陆`, 具体请看这篇[服务器基本操作文章](/server), 还需要安装各种`所需工具`和`环境变量`等，这个因为每个服务器不一样，所以需要根据你自己的实际情况进行安装

```sh
#!/bin/bash  ## 指定使用bash脚本

# 打包 .output 文件夹 为 dist.tar.gz
# -zcvf: 压缩文件, -z: 压缩, -c: 创建, -v: 显示详细信息, -f: 指定文件名
# dist.tar.gz: 压缩后的文件名
# .output: 要压缩的文件夹
tar -zcvf dist.tar.gz .output

# SCP 上传 dist.tar.gz 压缩包到 服务器
# SCP: 传输文件
# dist.tar.gz: 要上传的文件名
# user: 服务器用户名
# server: 服务器地址
# ~/admin: 服务器上的目标目录
scp dist.tar.gz user@server:~/admin

# 在服务器上解压 dist.tar.gz 压缩包
# ssh: 连接到服务器
# user@server: 服务器账号@服务器地址
# "tar -zxvf dist.tar.gz -C ~/admin": 在服务器运行的命令
## -zxvf: 解压文件, -z: 压缩, -x: 解压, -v: 显示详细信息, -f: 指定文件名
## dist.tar.gz: 需要解压的文件
## -C: 指定解压到的目录
## ~/admin: 服务器上的目标目录
ssh user@server "tar -zxvf dist.tar.gz -C ~/admin"

# 清理本地和服务器上的临时文件
rm dist.tar.gz # 清理本地压缩包
ssh user@server "rm ~/admin/dist.tar.gz" # 清理服务器上的压缩包
```

### 使用 pm2 管理和启动应用

主机上需要准备的环境:

- mongoDB
- Redis
- node>=20
- .env 文件

1. 连接进入服务器

```sh
ssh user@server
```

2. 将`.env`环境变量文件放置你需要启动的应用目录中

3. 安装`pm2`
   `pm2`在`node`模块已经详细介绍过，具体请看: [pm2 部署](/node/pm2)

```sh
npm install -g pm2
```

4. 启动并添加到`pm2`管理

```sh
# 查看是否安装成功
pm2 --version

# pm2 启动
# start: 启动应用
# --name: 设置应用的名称
# --node-args: 添加环境变量
# --env-file=.env: 指定环境变量文件
pm2 start .output/server/index.mjs --name [启动应用的名称] --node-args="--env-file=.env"
```

5.`pm2` 配置文件(可选)
加入你的环境变量过多, 可以在`pm2`的配置文件中进行配置, 具体请看: [官方文档](https://pm2.keymetrics.io/docs/usage/application-declaration/)

- 生成配置文件

```sh
pm2 init simple
```

- 配置文件(ecosystem.config.js)

```js
module.exports = {
  apps: [
    {
      name: "myApp", // 应用名称
      port: 3000, // 端口
      exec_mode: "cluster", // 模式, cluster: 集群模式, fork: 单进程模式
      script: "./output/server/index.mjs", // 脚本路径, 也就是要启动的应用
      instances: "max", // 实例数, max表示自动分配
      node_args: "--env-file=.env", // 设置变量，这里是设置指定环境变量文件
    },
  ],
};
```

## bun

[官网](https://bun.com/), `bun`是一个`node.js`的替代品, 速度更快, 更小, 更安全, 更易用

### 优势

1. `javascript-runtime`运行时，就是一个提供使用和运行程序的环境

- 速度快
- 全面兼容 `node.js` 的 `API`
- 直接支持`ts`
- 无脑支持`jsx`、`tsx`
- 原生兼容 `CJS/ESM`, 不需要任何配置，甚至在同一个文件中可以同时支持`import`和`require()`

2. 包管理器

- 兼容`node.js`
- 支持`monorepo`
- 速度快
- 全局`Cache(缓存)`

3. `Test Runner` 测试运行器

- 完全支持`jest`语法
- 速度快
- 自带 `DOM API`

### 安装

```sh
# mac 或者 linux
curl -fsSL https://bun.sh/install | bash

# windows
powershell -c "irm bun.sh/install.ps1 | iex"
```

### 天生支持环境变量

直接支持`.env`、`.env.production, .env.development, .env.test (depending on value of NODE_ENV)`、`.env.local`等，无需额外配置, [官方文档](https://bun.com/docs/runtime/env)<br />
例如: 刚刚的例子，是用`bun`运行

```sh
cd ~/admin
bun .output/server/index.mjs
```

### 配合 `pm2` 使用

配置文件(`ecosystem.config.js`)

```js
module.exports = {
  apps: [
    {
      name: "myApp", // 应用名称
      port: 3000, // 端口
      exec_mode: "cluster", // 模式, cluster: 集群模式, fork: 单进程模式
      script: "./output/server/index.mjs", // 脚本路径, 也就是要启动的应用
      instances: "max", // 实例数, max表示自动分配
      // node_args: "--env-file=.env", // 设置变量，这里是设置指定环境变量文件
      interpreter: "bun的路径", // 使用 bun 作为解释器, 使用 which bun 获取bun的路径，将bun的路径放进interpreter
    },
  ],
};
```
