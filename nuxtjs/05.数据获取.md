## 数据获取

`$fetch`: 发送网络请求函数，类似`axios`, [文档](https://github.com/unjs/ofetch)
`useAsyncData`: 在组件中发送异步请求的组合式函数, 可以配合`$fetch`一起使用
`useFetch`: 组合式函数，其实是`$fetch`和`useAsyncData`的语法糖，可以避免多次发送请求

## 开启代理

如果是服务端没进行`跨域处理`需要在`nuxt.config.ts`中开启`代理`，不然无法通过`跨域请求`

```ts
// https://nuxt.com/docs/apis/configuration/nuxt-config
export default defineNuxtConfig({
  // 开启ssr，默认是开启的
  ssr: true,
  // 限定发布nuxt版本的时间
  compatibilityDate: "2024-11-01",
  // 是否开启调试工具
  devtools: { enabled: true },
  // 导入依赖
  modules: ["@vant/nuxt", "@pinia/nuxt"],
  // pinia: {
  //   // autoImports 配置允许你在 stores 文件夹中直接使用 defineStore 而无需显式导入。
  //   autoImports: ['defineStore', 'acceptHMRUpdate'], // 自动导入 defineStore 和 HMR 支持
  // },
  // 扫描目录，自动导入
  imports: {
    dirs: ["Astores"],
  },
  // 配置运行时的公共变量
  runtimeConfig: {
    public: {
      apisBase: process.env.NUXT_PUBLIC_apis_BASE || "/apis", // 代理基础路径
    },
  },
  // 配置跨域
  nitro: {
    devProxy: {
      "/apis": {
        target: "http://localhost:8090", // 后端 apis 地址
        changeOrigin: true, // 修改 Origin 头为目标地址
        prependPath: true, // 保留 /apis 后的路径
        rewrite: (path) => path.replace(/^\/apis/, ""), // 移除 /apis 前缀
      },
    },
  },
});
```

## 测试 useFetch

当前测试的是我自己在本地开启的服务

```vue
<script lang="ts" setup>
<script lang="ts" setup>
/**
 * useFetch('apis',配置)
 * 如果需要筛选数据, 请在配置中添加 pick:['筛选的字段','筛选的字段',...]
 * @return { data, pending, error, refresh, execute, status }
 * 和vue3取值一样，需要取出数据都需要 .value
 * data: 返回的数据
 * pending: 布尔值，表示请求是否正在进行
 * error: 请求报错信息
 * refresh: 函数，用于手动重新触发请求
 * execute: 立即执行请求（通常在 lazy: true 时使用
 * status: 请求状态（'idle'、'pending'、'success'、'error'）
 */
const { data, pending, error, refresh, execute, status } = await useFetch(
  "https://jsonplaceholder.typicode.com/users",
  {
    // 筛选数据
    pick: ["id"],
    // 懒加载，添加以后，首页加的 NuxtLoadingIndicator 加载组件指示器没效果，
    // 需要自己添加加载效果，也就是 status 状态
    // 懒加载不会阻塞页面加载，如果不添加，会阻塞页面加载，等待该接口返回数据以后
    // 才会执行后续代码
    // 也可以使用 useAsyncData 代替 useFetch
    lazy: true,
  }
);
// 这是我本地的项目, 这是通过走代理的，也就是nuxt.config.ts配置natro.devProxy的
// const {
//   data: localData,
//   pending: localPending,
//   error: localError,
//   refresh: localRefresh,
//   execute: localExecute,
//   status: localStatus,
// } = await useFetch("apis/test");
// console.log(refresh.value);
console.log(data.value);
console.log(error.value);
console.log(status.value);
// console.log(localData.value);
</script>
<template>
  <div class="container">首页</div>
  <!-- 使用的vant组件 -->
  <van-button type="primary" size="small" @click="refresh?.()"
    >重载数据</van-button
  >
  <van-icon name="chat-o" />
  <!-- 使用自定义组件 -->
  <myLabel></myLabel>
</template>
<style lang="scss" scoped></style>
```

## $fetch

`$fetch`类似`axios`，使用方法也一样，但是在`nuxt`会有个`弊端`,因为`nuxt`是前后端一起构建的，所以会触发两次`$fetch`的请求

```vue
<script lang="ts" setup>
/**
 * $fetch('apis', 配置): 和fetch、axios的用法一样
 * 缺点: 在nuxt中因为会构建两次，一次是前端，一次是后端，所以使用 第三方请求库 或者 $fetch 都会发送两次请求
 */
const fetchData = await $fetch("https://jsonplaceholder.typicode.com/users");
console.log(fetchData);
// 这是我本地的项目, 这是通过走代理的，也就是nuxt.config.ts配置natro.devProxy的
$fetch("apis/test");
</script>
<template>
  <div class="container">首页</div>
  <!-- 使用的vant组件 -->
  <van-button type="primary" size="small" @click="refresh?.()"
    >重载数据</van-button
  >
  <van-icon name="chat-o" />
  <!-- 使用自定义组件 -->
  <myLabel></myLabel>
</template>
<style lang="scss" scoped></style>
```

## $fetch 和 useAsyncData 结合使用

`$fetch`和`useAsyncData`结合使用相当于`useFetch`,只不过会比`useFetch`更加灵活，可以使用`第三方请求库`

```vue
<script lang="ts" setup>

/**
 * useAsyncData(数据存储名称,()=>返回的是一个第三方库的请求结果或者$fetch请求结果)
 * $fetch和useAsyncData结合使用，相当于useFetch, 返回的也是一样
 */
const { data, pending, error, refresh, execute, status } = await useAsyncData(
  "userData",
  () => $fetch("https://jsonplaceholder.typicode.com/users")
);
console.log(data.value);
</script>
<template>
  <div class="container">首页</div>
  <!-- 使用的vant组件 -->
  <van-button type="primary" size="small" @click="refresh?.()">
    重载数据
  </van-button>
  <van-button type="primary" size="small" @click="remove("userData")">
    删除缓存的请求数据
  </van-button>
  <van-icon name="chat-o" />
  <!-- 使用自定义组件 -->
  <myLabel></myLabel>
</template>
<style lang="scss" scoped></style>

```

## 获取和删除请求所缓存的数据

```vue
<script lang="ts" setup>

/**
 * useAsyncData(数据存储名称,()=>返回的是一个第三方库的请求结果或者$fetch请求结果)
 * $fetch和useAsyncData结合使用，相当于useFetch, 返回的也是一样
 */
const { data, pending, error, refresh, execute, status } = await useAsyncData(
  "userData",
  () => $fetch("https://jsonplaceholder.typicode.com/users")
);
console.log(data.value);
// 获取存储的"userData"
const cacheUserData = useNuxtData("userData");
console.log(cacheUserData.data.value);

/**
 * 删除请求的缓存数据
 */
const remove = (key: string) => {
  clearNuxtData(key);
  console.log("userData 已清除");
};
</script>
<template>
  <div class="container">首页</div>
  <!-- 使用的vant组件 -->
  <van-button type="primary" size="small" @click="refresh?.()">
    重载数据
  </van-button>
  <van-button type="primary" size="small" @click="remove("userData")">
    删除缓存的请求数据
  </van-button>
  <van-icon name="chat-o" />
  <!-- 使用自定义组件 -->
  <myLabel></myLabel>
</template>
<style lang="scss" scoped></style>

```
