## 前言

根据前面的基础常用知识，也该开始写一写增删改查的基本项目

## 前端

使用的是`Vue3+Vite+TS+Axios+Element Plus`实现前端测试项目

### 创建项目

```sh
# 使用vite创建基本项目结构
npm create vite@latest [项目名称]

# 进入项目
cd [项目名称]

# 安装依赖
npm i

# 安装element plus和axios依赖
npm install element-plus --save
npm install axios

# 启动前端项目
npm run dev
```

使用`vite`创建基本项目架构

### 请求文件

```ts
// /axios/index.ts

import axios from "axios";
import { ElLoading, ElMessage } from "element-plus";

axios.defaults.baseURL = "/api";

const paramReset = (data?: any) => {
  if (!data) return;
  const obj = {
    ...data,
  };
  for (const key in obj) {
    const value = obj[key];
    if (value === "" || value === undefined || value === null) {
      delete obj[key];
    }
  }
  return obj;
};

export const createUser = (data?: any) => {
  return new Promise((resolve, reject) => {
    const loadding = ElLoading.service({
      text: "正在加载数据，请稍候...",
    });
    axios
      .post("/user", paramReset(data))
      .then((res) => {
        loadding.close();
        if (res.data.code != 200) {
          ElMessage.error(res.data.msg || "请求失败");
          reject(res.data.msg);
        } else {
          resolve(res.data);
        }
      })
      .catch((err) => {
        loadding.close();
        ElMessage.error(err || "请求失败");
        reject(err);
      });
  });
};
export const getUserList = (data?: any) => {
  return new Promise((resolve, reject) => {
    const loadding = ElLoading.service({
      text: "正在加载数据，请稍候...",
    });
    axios
      .get("/user", { params: paramReset(data) })
      .then((res) => {
        loadding.close();
        if (res.data.code != 200) {
          ElMessage.error(res.data.msg || "请求失败");
          reject(res.data.msg || "请求失败");
        } else {
          resolve(res.data);
        }
      })
      .catch((err) => {
        loadding.close();
        ElMessage.error(err || "请求失败");
        reject(err);
      });
  });
};
export const getUser = (data?: any) => {
  return new Promise((resolve, reject) => {
    const loadding = ElLoading.service({
      text: "正在加载数据，请稍候...",
    });
    axios
      .get(`/user/${data.id}`)
      .then((res) => {
        loadding.close();
        if (res.data.code != 200) {
          ElMessage.error(res.data.msg || "请求失败");
          reject(res.data.msg);
        } else {
          resolve(res.data);
        }
      })
      .catch((err) => {
        loadding.close();
        ElMessage.error(err || "请求失败");
        reject(err);
      });
  });
};
export const updateUser = (data?: any) => {
  return new Promise((resolve, reject) => {
    const loadding = ElLoading.service({
      text: "正在加载数据，请稍候...",
    });
    axios
      .patch(`/user/${data.id}`, data)
      .then((res) => {
        loadding.close();
        if (res.data.code != 200) {
          ElMessage.error(res.data.msg || "请求失败");
          reject(res.data.msg);
        } else {
          resolve(res.data);
        }
      })
      .catch((err) => {
        loadding.close();
        ElMessage.error(err || "请求失败");
        reject(err);
      });
  });
};
export const deleteUser = (data?: any) => {
  return new Promise((resolve, reject) => {
    const loadding = ElLoading.service({
      text: "正在加载数据，请稍候...",
    });
    axios
      .delete(`/user/delete`, { data })
      .then((res) => {
        loadding.close();
        if (res.data.code != 200) {
          ElMessage.error(res.data.msg || "请求失败");
          reject(res.data.msg);
        } else {
          resolve(res.data);
        }
      })
      .catch((err) => {
        loadding.close();
        ElMessage.error(err || "请求失败");
        reject(err);
      });
  });
};

export const createUserDetail = (data?: any) => {
  return new Promise((resolve, reject) => {
    const loadding = ElLoading.service({
      text: "正在加载数据，请稍候...",
    });
    axios
      .post("/user/addDetail", paramReset(data))
      .then((res) => {
        loadding.close();
        if (res.data.code != 200) {
          ElMessage.error(res.data.msg || "请求失败");
          reject(res.data.msg);
        } else {
          resolve(res.data);
        }
      })
      .catch((err) => {
        loadding.close();
        ElMessage.error(err || "请求失败");
        reject(err);
      });
  });
};

export const addUserPhoto = (data?: any) => {
  return new Promise((resolve, reject) => {
    const loadding = ElLoading.service({
      text: "正在加载数据，请稍候...",
    });
    axios
      .post("/user/addPhoto", paramReset(data))
      .then((res) => {
        loadding.close();
        if (res.data.code != 200) {
          ElMessage.error(res.data.msg || "请求失败");
          reject(res.data.msg);
        } else {
          resolve(res.data);
        }
      })
      .catch((err) => {
        loadding.close();
        ElMessage.error(err || "请求失败");
        reject(err);
      });
  });
};
```

### 前端全代码

1. user.vue
   包括增删改查功能, 模拟添加图片，添加别的信息

```vue
<script lang="ts" setup>
import {
  createUser,
  getUserList,
  //   getUser,
  updateUser,
  deleteUser,
} from "../axios/index";
import { ref, reactive, nextTick, watch, onBeforeMount } from "vue";
import type {
  InputInstance,
  TableInstance,
  FormInstance,
  FormRules,
} from "element-plus";
import { ElMessage, ElMessageBox } from "element-plus";

// 添加详情弹窗
import DetailPopCm from "./userDetailPop.vue";
const DetailPopCmRef = ref<InstanceType<typeof DetailPopCm>>();
import PhotoPopCm from "./photoPop.vue";
const PhotoPopCmRef = ref<InstanceType<typeof PhotoPopCm>>();

/**
 * 深拷贝
 * @param obj
 * @param hash
 */
function deepCopy(obj: any, hash = new WeakMap()) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (hash.has(obj)) {
    return hash.get(obj);
  }

  const copy: any = Array.isArray(obj) ? [] : {};
  hash.set(obj, copy);

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = deepCopy(obj[key], hash);
    }
  }

  return copy;
}

// 搜索的form表
const searchForm = reactive<any>({
  name: "",
  is_member: "",
});
const fromCm = ref<FormInstance>(); // 表单实例
/**
 * 表单验证
 */
const rules = reactive<FormRules>({
  name: [{ required: true, message: "请输入名字", trigger: "blur" }],
  age: [{ required: true, message: "请输入年龄", trigger: "blur" }],
  is_member: [{ required: true, message: "请选择是否是会员", trigger: "blur" }],
  sex: [{ required: true, message: "请选择性别", trigger: "blur" }],
  address: [{ required: true, message: "请输入地址", trigger: "blur" }],
});
const buttonMethod = ref(""); // 当前按钮点击事件
const inputValue = ref<string>(""); // 爱好输入框的值
const inputVisible = ref(false); // 是否显示爱好输出框
const InputRef = ref<InputInstance>(); // 爱好输入框实例
const dialogFormVisible = ref(false); // 是否显示弹窗
const tableRef = ref<TableInstance>(); // 弹窗实例
const tableData = ref<any[]>([]); // 列表数据
// 新增或编辑数据的form表单
const form: any = ref({
  name: "",
  age: "",
  is_member: "",
  sex: "",
  address: "",
  hobby: [],
});
// 分页数据配置
const pagination = reactive({
  currentPage: 1,
  pageSize: 10,
  sizeList: [10, 20, 30, 50, 100],
  total: 2,
});
// 监听是否关闭弹窗，关闭就清空新增或编辑的form表单的数据
watch(
  () => dialogFormVisible.value,
  () => {
    if (!dialogFormVisible.value) {
      fromCm.value?.clearValidate();
      for (const key in form.value) {
        const value = form.value[key];
        form.value[key] = Array.isArray(value) ? [] : "";
      }
    }
  }
);

/**
 * 处理点击事件
 * @param type "create": 新增 | "edit": 更新编辑 | "delete"：删除 | "search"：搜索 | "reset"：重置搜索表单 | 'detail': 添加详细信息 | 'photo': 添加图片
 * @param data 是否有原始数据
 */
const handleManage = (
  type: "create" | "edit" | "delete" | "search" | "reset" | "detail" | "photo",
  data?: any
) => {
  console.log(type, data);
  buttonMethod.value = type;
  switch (type) {
    case "create":
    case "edit":
      dialogFormVisible.value = !dialogFormVisible.value;
      if (data) {
        form.value = deepCopy(data);
      }

      break;
    case "delete":
      const dataList = data ? [data] : tableRef.value?.getSelectionRows();
      if (!dataList.length) {
        ElMessage.warning("请选择需要删除的数据");
        return;
      }
      deleteData(dataList);
      break;
    case "search":
      pagination.total = 0;
      pagination.currentPage = 1;
      getList();
      break;
    case "reset":
      for (const key in searchForm) {
        const value = searchForm[key];
        searchForm[key] = Array.isArray(value) ? [] : "";
      }
      break;
    case "detail":
      DetailPopCmRef.value?.handleVisiable(data);
      break;
    case "photo":
      PhotoPopCmRef.value?.handleVisiable(data);
      break;
    default:
      break;
  }
};

// 删除数据
var deleteData = (list: any[]) => {
  const title = list.map((item: any) => item.name);
  const ids = list.map((item: any) => item.id);
  ElMessageBox.confirm(`是否确认删除${title.join(",")}?`, "Warning", {
    confirmButtonText: "确认",
    cancelButtonText: "取消",
    type: "warning",
  })
    .then(() => {
      deleteUser({ ids: ids.join(",") })
        .then((res: any) => {
          ElMessage.success(res.msg);
          getList();
        })
        .catch((err) => {
          ElMessage.error(err);
        });
    })
    .catch(() => {});
};

// 改变当前页或当前页数据总数的回调
const handlePagination = (key: "pageSize" | "currentPage", value: any) => {
  pagination[key] = value;
  if (key == "pageSize") {
    pagination.currentPage = 1;
  }
  getList();
};

// 删除爱好列表中的数据
const handleClose = (tag: string) => {
  form.value.hobby.splice(form.value.hobby.indexOf(tag), 1);
};

// 显示爱好输入框
const showInput = () => {
  inputVisible.value = true;
  nextTick(() => {
    InputRef.value!.input!.focus();
  });
};
// 爱好输入框按enter事件回调
const handleInputConfirm = () => {
  if (inputValue.value) {
    form.value.hobby.push(inputValue.value);
  }
  inputVisible.value = false;
  inputValue.value = "";
};
// 创建或更新数据
const submit = async () => {
  if (!fromCm.value) return;
  const validate = await fromCm.value.validate(() => {});
  if (!validate) return;
  console.log(validate, form.value);
  const req = buttonMethod.value == "create" ? createUser : updateUser;
  req(form.value)
    .then((res: any) => {
      dialogFormVisible.value = false;
      ElMessage.success(res.msg);
      pagination.total = 0;
      pagination.currentPage = 1;
      getList();
    })
    .catch((err) => {
      ElMessage.error(err);
    });
};
// 获取列表数据
var getList = () => {
  getUserList({
    page: pagination.currentPage,
    pageSize: pagination.pageSize,
    name: searchForm.name,
    is_member: searchForm.is_member,
  }).then((res: any) => {
    tableData.value = res?.list || [];
    pagination.total = res.total || 0;
  });
};
// 挂载前获取列表数据
onBeforeMount(() => {
  console.log(form.value);

  getList();
});
</script>
<template>
  <div class="user-container">
    <div class="search">
      <el-form-item label="姓名" prop="name" :label-width="50">
        <el-input
          style="width: 150px"
          placeholder="请输入"
          v-model="searchForm.name"
          autocomplete="off"
          clearable
        />
      </el-form-item>
      <el-form-item label="会员" prop="is_member" :label-width="50">
        <el-select
          style="width: 180px"
          v-model="searchForm.is_member"
          placeholder="请选择是否是会员"
          clearable
        >
          <el-option label="是" :value="1" />
          <el-option label="否" :value="0" />
        </el-select>
      </el-form-item>
      <el-button
        style="margin-bottom: 18px; margin-left: 14px"
        type="primary"
        @click="handleManage('search')"
        >搜索</el-button
      >
      <el-button
        style="margin-bottom: 18px"
        type="default"
        @click="handleManage('reset')"
        >重置</el-button
      >
    </div>
    <div>
      <el-button type="primary" @click="handleManage('create')">新增</el-button>
      <el-button type="danger" @click="handleManage('delete')">删除</el-button>
    </div>
    <div class="table-box">
      <el-table
        ref="tableRef"
        :data="tableData"
        style="width: 100%"
        height="100%"
        border
        stripe
      >
        <el-table-column type="selection" width="55" align="center" />
        <el-table-column prop="name" label="姓名" align="center" />
        <el-table-column prop="age" label="年龄" align="center" />
        <el-table-column prop="sex" label="性别" align="center" />
        <el-table-column prop="address" label="地址" align="center" />
        <el-table-column label="爱好" align="center">
          <template #default="scoped">
            <el-tag
              style="margin-right: 10px"
              v-for="tag in scoped.row.hobby"
              :key="tag"
            >
              {{ tag }}
            </el-tag>
          </template>
        </el-table-column>
        <el-table-column prop="createTime" label="创建时间" align="center" />
        <el-table-column label="操作" width="260" align="center">
          <template #default="scoped">
            <el-button
              type="primary"
              text
              @click="handleManage('detail', scoped.row)"
              >添加信息</el-button
            >
            <el-button
              type="primary"
              text
              @click="handleManage('photo', scoped.row)"
              >添加图片</el-button
            >
            <el-button
              type="primary"
              text
              @click="handleManage('edit', scoped.row)"
              >修改</el-button
            >
            <el-button
              type="danger"
              text
              @click="handleManage('delete', scoped.row)"
              >删除</el-button
            >
          </template>
        </el-table-column>
      </el-table>
    </div>
    <!-- 分页管理 -->
    <div class="bottom">
      <el-pagination
        :current-page="pagination.currentPage"
        :page-size="pagination.pageSize"
        :page-sizes="pagination.sizeList"
        layout="total, sizes, prev, pager, next, jumper"
        :total="pagination.total"
        @size-change="(value:any) => handlePagination('pageSize', value)"
        @current-change="(value:any) => handlePagination('currentPage', value)"
      />
    </div>

    <el-dialog v-model="dialogFormVisible" title="新增个人信息">
      <el-form ref="fromCm" :model="form" :rules="rules">
        <el-form-item label="姓名" prop="name" :label-width="120">
          <el-input v-model="form.name" placeholder="请输入" />
        </el-form-item>
        <el-form-item label="性别" prop="sex" :label-width="120">
          <el-select v-model="form.sex" placeholder="请选择性别">
            <el-option label="男" value="男" />
            <el-option label="女" value="女" />
          </el-select>
        </el-form-item>
        <el-form-item label="年龄" prop="age" :label-width="120">
          <el-input
            v-model="form.age"
            type="number"
            placeholder="请输入"
            @input="(value:any) => form.age = Number(value)"
          />
        </el-form-item>
        <el-form-item label="地址" prop="address" :label-width="120">
          <el-input v-model="form.address" placeholder="请输入" />
        </el-form-item>
        <el-form-item label="会员" prop="is_member" :label-width="120">
          <el-select v-model="form.is_member" placeholder="请选择是否是会员">
            <el-option label="是" value="1" />
            <el-option label="否" value="0" />
          </el-select>
        </el-form-item>
        <el-form-item label="爱好" prop="hobby" :label-width="120">
          <el-tag
            style="margin-right: 10px"
            v-for="tag in form.hobby"
            :key="tag"
            closable
            :disable-transitions="false"
            @close="handleClose(tag)"
          >
            {{ tag }}
          </el-tag>
          <el-input
            v-if="inputVisible"
            ref="InputRef"
            v-model="inputValue"
            style="width: 20%"
            size="small"
            @keyup.enter="handleInputConfirm"
            @blur="handleInputConfirm"
          />
          <el-button
            v-else
            class="button-new-tag"
            size="small"
            @click="showInput"
          >
            + 爱好
          </el-button>
        </el-form-item>
      </el-form>
      <template #footer>
        <div class="dialog-footer">
          <el-button @click="dialogFormVisible = false">取消</el-button>
          <el-button type="primary" @click="submit"> 确定 </el-button>
        </div>
      </template>
    </el-dialog>

    <!-- 详情弹窗 -->
    <DetailPopCm ref="DetailPopCmRef" @update="getList" />
    <PhotoPopCm ref="PhotoPopCmRef" @update="getList" />
  </div>
</template>
<style scoped>
.user-container {
  width: 100vw;
  height: 100vh;
  padding: 20px;
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}

.search {
  width: 100%;
  display: flex;
  align-items: center;
}

.table-box {
  flex: 1;
  height: 0;
  width: 100%;
  margin-top: 20px;
}
.bottom {
  width: 100%;
  display: flex;
  flex-direction: row-reverse;
  margin-top: 20px;
}
</style>
```

2. userDetailPop.vue
   测试`nestjs`的`typeorm`中的`一对一`的表关系

```vue
<script lang="ts" setup>
import { reactive, ref } from "vue";
import { ElMessage, type FormInstance, type FormRules } from "element-plus";
import { createUserDetail } from "../axios/index";

interface Form {
  email: string;
  phone: string;
  userId: string;
}
const emits = defineEmits(["update"]);
const visiable = ref(false);
const formRef = ref<FormInstance>();
const form = reactive<Form>({
  email: "",
  phone: "",
  userId: "",
});
const rules = reactive<FormRules>({
  email: [
    {
      trigger: "blur",
      message: "请输入邮件",
      required: true,
    },
  ],
  phone: [
    {
      trigger: "blur",
      message: "请输入电话号码",
      required: true,
    },
  ],
});

const handleVisiable = (data?: any) => {
  visiable.value = !visiable.value;
  if (data) {
    form.userId = data?.id;
  }
};
const closeDialog = () => {
  for (const key in form) {
    form[key as keyof Form] = "";
  }
};
// 创建或更新数据
const submit = async () => {
  if (!formRef.value) return;
  const validate = await formRef.value.validate(() => {});
  if (!validate) return;
  createUserDetail(form).then((res: any) => {
    visiable.value = false;
    ElMessage.success(res.msg);
    emits("update");
  });
};
defineExpose({
  handleVisiable,
});
</script>
<template>
  <div class="user-detail-container">
    <el-dialog
      v-model="visiable"
      title="添加详细信息"
      width="50%"
      @close="closeDialog"
    >
      <el-form ref="formRef" :model="form" :rules="rules">
        <el-form-item label="邮件" prop="email">
          <el-input placeholder="请输入邮件" v-model="form.email" />
        </el-form-item>
        <el-form-item label="电话号码" prop="phone">
          <el-input placeholder="请输入电话号码" v-model="form.phone" />
        </el-form-item>
      </el-form>
      <template #footer>
        <div class="dialog-footer">
          <el-button @click="handleVisiable">取消</el-button>
          <el-button type="primary" @click="submit"> 确定 </el-button>
        </div>
      </template>
    </el-dialog>
  </div>
</template>
<style scoped></style>
```

3. photo.vue
   因为偷懒，没真正录入真是图片，只是用来测试`nestjs`的`typeorm`中的`一对多和多对一`的表关系

```vue
<script lang="ts" setup>
import { reactive, ref } from "vue";
import { ElMessage, type FormInstance, type FormRules } from "element-plus";
import { addUserPhoto } from "../axios/index";

interface Form {
  name: string;
  photo: string;
  userId: string;
}
const emits = defineEmits(["update"]);
const visiable = ref(false);
const formRef = ref<FormInstance>();
const form = reactive<Form>({
  name: "",
  photo: "",
  userId: "",
});
const rules = reactive<FormRules>({
  name: [
    {
      trigger: "blur",
      message: "请输入照片名称",
      required: true,
    },
  ],
  photo: [
    {
      trigger: "blur",
      message: "请输入照片",
      required: true,
    },
  ],
});

const handleVisiable = (data?: any) => {
  visiable.value = !visiable.value;
  if (data) {
    form.userId = data?.id;
  }
};
const closeDialog = () => {
  for (const key in form) {
    form[key as keyof Form] = "";
  }
};
// 创建或更新数据
const submit = async () => {
  if (!formRef.value) return;
  const validate = await formRef.value.validate(() => {});
  if (!validate) return;
  addUserPhoto(form).then((res: any) => {
    visiable.value = false;
    ElMessage.success(res.msg);
    emits("update");
  });
};
defineExpose({
  handleVisiable,
});
</script>
<template>
  <div class="photo-container">
    <el-dialog
      v-model="visiable"
      title="添加照片"
      width="50%"
      @close="closeDialog"
    >
      <el-form ref="formRef" :model="form" :rules="rules">
        <el-form-item label="照片名称" prop="name">
          <el-input placeholder="请输入照片名称" v-model="form.name" />
        </el-form-item>
        <el-form-item label="照片" prop="photo">
          <el-input placeholder="请输入照片" v-model="form.photo" />
        </el-form-item>
      </el-form>
      <template #footer>
        <div class="dialog-footer">
          <el-button @click="handleVisiable">取消</el-button>
          <el-button type="primary" @click="submit"> 确定 </el-button>
        </div>
      </template>
    </el-dialog>
  </div>
</template>
<style scoped></style>
```

## 后端

使用`nestjs`实现接口，数据库使用的是`关系型数据库MySQL`，操作数据用的是`prisma`

### 创建项目

```sh
# 使用nest/clic 创建后端基本项目机构
nest new [项目名称]

# 进入项目
cd [项目名称]

# 安装所需依赖
# Nest 提供了 `@nestjs/typeorm` 包
# `TypeORM`:  是可用于 `TypeScript` 的最成熟的`对象关系映射器 (ORM)`。
# mysql2: 数据库
npm install --save @nestjs/typeorm typeorm mysql2
# 安装验证器
npm i --save class-validator class-transformer

# 安装user的curd模板
nest g res user
# 安装user的管道，用作dto层检验
nest g pi user

# 热启动项目
npm run start:dev
```

### 编写 dto 层

```ts
// create-user.dto.ts

import {
  IsNotEmpty,
  IsString,
  IsNumber,
  IsEnum,
  IsArray,
} from "class-validator";

enum Sex {
  MAN = "男",
  WOMEN = "女",
}

enum Member {
  YES = "1",
  No = "0",
}

export class CreateUserDto {
  @IsNotEmpty({ message: "名称不能为空" })
  @IsString({ message: "名称类型是string" })
  name: string;

  @IsNotEmpty({ message: "年龄不能为空" })
  @IsNumber(
    { allowNaN: false, maxDecimalPlaces: 0 },
    { message: "年龄只能是number类型" }
  )
  age: number;

  @IsEnum(Sex, { message: "性别只能是<男>或者<女>" })
  sex: Sex;

  @IsArray({ message: "爱好是数组类型" })
  hobby: any[];

  @IsNotEmpty({ message: "地址不能为空" })
  @IsString({ message: "地址类型是string" })
  address: string;

  @IsEnum(Member, { message: "是否是会员，值有: 1, 0" })
  is_member: Member;
}
```

### 编写验证 dto 通道

```ts
// user.pipe.ts

import {
  ArgumentMetadata,
  HttpException,
  HttpStatus,
  Injectable,
  PipeTransform,
} from "@nestjs/common";
import { plainToInstance } from "class-transformer";
import { validate } from "class-validator";

@Injectable()
export class UserPipe implements PipeTransform {
  async transform(value: any, metadata: ArgumentMetadata) {
    if (!metadata.metatype) {
      return value;
    }
    // 实例化dto
    const DTO = plainToInstance(metadata.metatype, value);
    // 验证, 返回的是验证错误数组
    const validateErrors = await validate(DTO);
    if (validateErrors.length > 0) {
      const errors = validateErrors.map((item) => item.constraints);
      // 抛出错误
      throw new HttpException(
        {
          code: 400,
          msg: "参数错误",
          errors,
        },
        HttpStatus.BAD_REQUEST,
        {
          cause: validateErrors,
        }
      );
      // return validateErrors
    }
    return value;
  }
}
```

### 连接数据库

```ts
// app.module.ts

import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { UserModule } from "./user/user.module";
import { TypeOrmModule } from "@nestjs/typeorm";

@Module({
  imports: [
    UserModule,
    // 连接数据库
    TypeOrmModule.forRoot({
      type: "mysql", // 数据库类型
      database: "nestjs", // 数据库名称
      host: "127.0.0.1", // 数据库地址
      port: 3306, // 数据库端口
      username: "root", // 数据库账号
      password: "123456", // 数据库密码
      entities: [__dirname + "/**/*.entity{.ts,.js}"], // 实体文件, 也就是使用@Entity()装饰器注入的文件
      synchronize: true, // synchronize字段代表是否自动将实体类同步到数据库
      retryDelay: 500, // 重试连接数据库间隔
      retryAttempts: 10, // 重试连接数据库的次数
      autoLoadEntities: true, // 如果为true,将自动加载实体 forFeature()方法注册的每个实体都将自动添加到配置对象的实体数组中
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

### 编写实体文件

实体文件其实就是`建表`

1. user.entity.ts
   与子表`detail`形成`一对一`关系，通过`@OneToOne`进行连接。<br />
   与子表`photo`形成`一对多`关系, `user`通过`@OneToMany`, `photo`通过`@ManyToOne`来互相连接

```ts
// user.entity.ts

import {
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  Entity,
  OneToOne,
  JoinColumn,
  OneToMany,
} from "typeorm";
import { UserDetail } from "./detail.entity";
import { Photos } from "./photo.entity";

@Entity()
export class User {
  @PrimaryGeneratedColumn("uuid")
  // @Column({ type: 'varchar', length: 288, comment: '用户id' })
  id: string;

  @Column({ type: "varchar", length: 288, comment: "名称" })
  name: string;

  @Column({ type: "int", comment: "年龄" })
  age: number;

  @Column({ type: "enum", enum: ["男", "女"], comment: "性别" })
  sex: "男" | "女";

  @Column({ type: "simple-array", comment: "爱好", nullable: true })
  hobby: Array<string>;

  @Column({ type: "simple-json", comment: "简单对象", nullable: true })
  profile: any;

  @Column({ type: "varchar", length: 255, comment: "地址" })
  address: string;

  @Column({ type: "enum", enum: ["1", "0"], comment: "是否是会员" })
  is_member: "1" | "0";

  @CreateDateColumn({ type: "timestamp", comment: "创建时间" })
  createTime: Date;

  // 一对一关系，只需要在父表中添加 @OneToOne(() => UserDetail),并指向需要的子表
  @OneToOne(() => UserDetail)
  // @JoinColumn() 存储外键
  @JoinColumn()
  detail: UserDetail;

  // 一对多关系，@OneToMany(()=>Photos: 对应的子表,(photos)=>photos.user： 对应子表中的column)
  @OneToMany(() => Photos, (photos) => photos.user)
  photos: Photos[];
}
```

2. detail.entity.ts
   与主表`user`形成`一对一关系`

```ts
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class UserDetail {
  @PrimaryGeneratedColumn("uuid", { comment: "用户详情id" })
  id: string;

  @Column({ type: "varchar", comment: "用户邮件" })
  email: string;

  @Column({ type: "varchar", comment: "用户电话" })
  phone: string;
}
```

3. photo.entity.ts
   与主表`user`形成`多对一关系`

```ts
import { PrimaryGeneratedColumn, Column, ManyToOne, Entity } from "typeorm";
import { User } from "./user.entity";

@Entity()
export class Photos {
  @PrimaryGeneratedColumn("uuid", { comment: "用户存储图片id" })
  id: string;

  @Column({ type: "varchar", length: 888, comment: "图片链接" })
  url: string;

  @Column({ comment: "图片名称", nullable: true })
  name: string;

  // 多对一，@ManyToOne(()=>User： 指定主表, (user)=>user.photos：主表中对应的column)
  @ManyToOne(() => User, (user) => user.photos)
  user: User;
}
```

### 在 user 模块 使用 user 表

```ts
// user.module.ts

import { Module } from "@nestjs/common";
import { UserService } from "./user.service";
import { UserController } from "./user.controller";
import { TypeOrmModule } from "@nestjs/typeorm";
import { User } from "./entities/user.entity";
import { UserDetail } from "./entities/detail.entity";
import { Photos } from "./entities/photo.entity";

@Module({
  imports: [TypeOrmModule.forFeature([User, UserDetail, Photos])],
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}
```

### 在 service 层导入和使用 user 表

```ts
// user.service.ts

import { Injectable } from "@nestjs/common";
import { CreateUserDto } from "./dto/create-user.dto";
import { UpdateUserDto } from "./dto/update-user.dto";
import { InjectRepository } from "@nestjs/typeorm";
import { Like, Repository } from "typeorm";
import { User } from "./entities/user.entity";
import { UserDetail } from "./entities/detail.entity";
import { Photos } from "./entities/photo.entity";

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User) private readonly userRepository: Repository<User>,
    @InjectRepository(UserDetail)
    private readonly UserDetailRepository: Repository<UserDetail>,
    @InjectRepository(Photos)
    private readonly UserPhotoRepository: Repository<Photos>
  ) {}

  async create(createUserDto: CreateUserDto) {
    try {
      const result = await this.userRepository.save(createUserDto);
      return {
        code: 200,
        data: result,
        msg: "创建成功",
      };
    } catch (error) {
      return {
        code: 400,
        msg: "创建失败",
      };
    }
  }

  async findAll(query: any) {
    const list = await this.userRepository.find({
      where: {
        name: Like(`%${query.name || ""}%`),
        is_member: query.is_member || null,
      },
      skip: (query.page - 1) * query.pageSize,
      take: query.pageSize,
      order: {
        id: "DESC",
      },
      relations: ["detail", "photos"],
    });
    const total = await this.userRepository.count();
    return {
      code: 200,
      list,
      total,
      msg: "获取成功",
    };
  }

  findOne(id: number) {
    return `This action returns a #${id} user`;
  }

  async update(id: string | number, updateUserDto: UpdateUserDto) {
    try {
      const result = await this.userRepository.update(id, updateUserDto);
      return {
        code: 200,
        msg: "更新成功",
        data: result,
      };
    } catch (error) {
      return {
        code: 400,
        msg: "更新失败",
      };
    }
  }

  async remove(ids: string) {
    try {
      const result = await this.userRepository.delete(ids.split(","));
      return {
        code: 200,
        msg: "删除成功",
        data: result,
      };
    } catch (error) {
      return {
        code: 400,
        msg: "删除失败",
      };
    }
  }

  async addDetail(body: any) {
    try {
      const user: any = await this.userRepository.findOne({
        where: { id: body?.userId },
      });
      const detail = new UserDetail();
      detail.email = body?.email;
      detail.phone = body?.phone;
      user.detail = detail;
      const detailData = await this.UserDetailRepository.save(detail);
      const result = await this.userRepository.save(user);
      return {
        code: 200,
        data: result,
        msg: "添加成功",
      };
    } catch (error) {
      console.log(error);

      return {
        code: 400,
        msg: "添加失败",
      };
    }
  }

  async addPhoto(body: any) {
    try {
      const user: any = await this.userRepository.findOne({
        where: { id: body?.userId },
      });
      const photos = new Photos();
      photos.name = body?.name;
      photos.url = body?.photo;
      user.photos = [photos];
      await this.UserPhotoRepository.save(photos);
      const result = await this.userRepository.save(user);
      return {
        code: 200,
        data: result,
        msg: "添加成功",
      };
    } catch (error) {
      console.log(error);

      return {
        code: 400,
        msg: "添加失败",
      };
    }
  }
}
```

## 表和表关系

实际项目中，一般表与表之间都会存在多种关系

### 一对一

一对一是一种 A 只包含一个 B 实例，而 B 只包含一个 A 实例的关系。 我们以 User 和 Profile 实体为例。

1. `user.entity.ts`: 用户只能拥有一个配置文件，并且一个配置文件仅由一个用户拥有。

```ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToOne,
  JoinColumn,
} from "typeorm";
import { Profile } from "./Profile";

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @OneToOne(() => Profile) // 将Profile表映射关系到user表
  @JoinColumn() // 自动添加列
  profile: Profile;
}
```

2. `profile.entity.ts`

```ts
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class Profile {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  gender: string;

  @Column()
  photo: string;
}
```

3. 使用

- 保存

```ts
const profile = new Profile();
profile.gender = "male";
profile.photo = "me.jpg";
await connection.manager.save(profile);

const user = new User();
user.name = "Joe Smith";
user.profile = profile;
await connection.manager.save(user);
```

- 查询
  通过`relations`指定子表返回

```ts
const userRepository = connection.getRepository(User);
const users = await userRepository.find({ relations: ["profile"] });
```

### 一对多和多对一

`多对一`/`一对多`是指 A 包含多个 B 实例的关系，但 B 只包含一个 A 实例。 让我们以 User 和 Photo 实体为例。 User 可以拥有多张 photos，但每张 photo 仅由一位 user 拥有
这里我们将`@OneToMany`添加到`photos`属性中，并将目标关系类型指定为`Photo`。 你可以在`@ManyToOne` / `@OneToMany`关系中省略`@JoinColumn`，除非你需要自定义关联列在数据库中的名称。
`@ManyToOne`可以单独使用，但` @OneToMany``必须 `搭配`@ManyToOne`使用。 如果你想使用`@OneToMany`，则需要`@ManyToOne`。 在你设置`@ManyToOne`的地方，`相关实体将有"关联 id"和外键`。

```ts
// photo.entity.ts

import { Entity, PrimaryGeneratedColumn, Column, ManyToOne } from "typeorm";
import { User } from "./User";

@Entity()
export class Photo {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  url: string;

  @ManyToOne(() => User, (user) => user.photos)
  user: User;
}
```

```ts
// user.entity.ts

import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from "typeorm";
import { Photo } from "./Photo";

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  @OneToMany(() => Photo, (photo) => photo.user)
  photos: Photo[];
}
```

- 保存

```ts
const photo1 = new Photo();
photo1.url = "me.jpg";
await connection.manager.save(photo1);

const photo2 = new Photo();
photo2.url = "me-and-bears.jpg";
await connection.manager.save(photo2);

const user = new User();
user.name = "John";
user.photos = [photo1, photo2];
await connection.manager.save(user);
```

- 查询

```ts
const userRepository = connection.getRepository(User);
const users = await userRepository.find({ relations: ["photos"] });

// or from inverse side

const photoRepository = connection.getRepository(Photo);
const photos = await photoRepository.find({ relations: ["user"] });
```

### 多对多

多对多是一种 A 包含多个 B 实例，而 B 包含多个 A 实例的关系。 我们以 Question 和 Category 实体为例。 Question 可以有多个 categories, 每个 category 可以有多个 questions。

```ts
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity()
export class Category {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;
}
```

```ts
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToMany,
  JoinTable,
} from "typeorm";
import { Category } from "./Category";

@Entity()
export class Question {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  text: string;

  @ManyToMany(() => Category)
  @JoinTable()
  categories: Category[];
}
```

- 保存

```ts
const category1 = new Category();
category1.name = "animals";
await connection.manager.save(category1);

const category2 = new Category();
category2.name = "zoo";
await connection.manager.save(category2);

const question = new Question();
question.categories = [category1, category2];
await connection.manager.save(question);
```

- 查询

```ts
const questionRepository = connection.getRepository(Question);
const questions = await questionRepository.find({ relations: ["categories"] });
```
