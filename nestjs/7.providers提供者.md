## 提供者(Providers)

`Providers` 是 Nest 的一个基本概念。许多基本的 Nest 类可能被视为 `provider-service, repository, factory, helper` 等等。
他们都可以通过 `constructor` 注入`依赖关系`。 这意味着对象可以彼此创建各种关系，并且“连接”对象实例的功能在很大程度上可以委托给 Nest 运行时系统。
`Provider` 只是一个用 `@Injectable() 装饰器`注释的类

### 基本用法

1. 注入`providers`，形成依赖关系

```ts
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service"; // 引入service类

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService], // 注入AppService，AppService通过@Injectable()形成依赖关系
})
export class AppModule {}
```

2. 使用，在`app.controller.ts`中注入依赖并使用

```ts
import { Controller, Get } from "@nestjs/common";
import { AppService } from "./app.service"; // 引入通过在app.module.ts中注入AppService

@Controller()
export class AppController {
  // 在constructor中注入依赖
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```

### 自定义名称

通过 `useClass` 实现

1. 注入`providers`，形成依赖关系

```ts
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
// import { TestModule } from './test/test.module';
import { TestController } from "./test/test.controller";
import { TestService } from "./test/test.service";

@Module({
  imports: [],
  controllers: [AppController, TestController],
  // 注入AppService，AppService通过@Injectable()形成依赖关系
  providers: [
    AppService,
    {
      provide: "testName", // 自定义名称
      useClass: TestService, // 定义名称所用的service
    },
  ],
})
export class AppModule {}
```

2. 使用，在`test.controller.ts`中注入依赖并使用

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Inject,
} from "@nestjs/common";
import { TestService } from "./test.service";
import { CreateTestDto } from "./dto/create-test.dto";
import { UpdateTestDto } from "./dto/update-test.dto";

@Controller("test")
export class TestController {
  // 自定义名称注入依赖，通过 @Inject(在app.module.ts中所自定义的名称)，通过该名称确定依赖关系
  constructor(@Inject("test-name") private readonly testService: TestService) {}
}
```

### 自定义注入值

通过 `useValue` 实现

1. 注入`providers`，形成依赖关系

```ts
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
// import { TestModule } from './test/test.module';
import { TestController } from "./test/test.controller";
import { TestService } from "./test/test.service";

@Module({
  imports: [],
  controllers: [AppController, TestController],
  // 注入AppService，AppService通过@Injectable()形成依赖关系
  providers: [
    {
      provide: "myInfo", // 自定义名称
      useValue: {
        // 自定义注入值
        name: "某人",
        age: 188,
        adress: "某处",
      },
    },
  ],
})
export class AppModule {}
```

2. 使用，在`test.controller.ts`中注入依赖并使用

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Inject,
} from "@nestjs/common";
import { TestService } from "./test.service";
import { CreateTestDto } from "./dto/create-test.dto";
import { UpdateTestDto } from "./dto/update-test.dto";

@Controller("test")
export class TestController {
  // 自定义名称注入依赖，通过 @Inject(在app.module.ts中所自定义的名称)，通过该名称确定依赖关系
  constructor(@Inject("myInfo") private readonly myinfo: any) {
    console.log(this.myinfo);
  }
}
```

### 工厂模式

如果服务 之间有相互的依赖 或者逻辑处理 可以使用 `useFactory`, `useFactory`可以使用`异步形式`

1. test.service.ts

```ts
import { Injectable } from "@nestjs/common";
import { CreateTestDto } from "./dto/create-test.dto";
import { UpdateTestDto } from "./dto/update-test.dto";

@Injectable()
export class TestService {
  create(createTestDto: CreateTestDto) {
    return "This action adds a new test";
  }

  findAll() {
    return `This action returns all test`;
  }

  findOne(id: number) {
    return `This action returns a #${id} test`;
  }

  update(id: number, updateTestDto: UpdateTestDto) {
    return `This action updates a #${id} test`;
  }

  remove(id: number) {
    return `This action removes a #${id} test`;
  }
}

@Injectable()
export class TestService1 {
  create(createTestDto: CreateTestDto) {
    return createTestDto;
  }
}

@Injectable()
export class TestService2 {
  value: any;
  constructor(value) {
    console.log(value);
    this.value = value;
  }
  create() {
    return "TestService2 ------------ " + this.value;
  }
}
```

2. 注入`providers`，形成依赖关系

```ts
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
// import { TestModule } from './test/test.module';
import { TestController } from "./test/test.controller";
import { TestService, TestService1, TestService2 } from "./test/test.service";

@Module({
  imports: [],
  controllers: [AppController, TestController],
  // 注入AppService，AppService通过@Injectable()形成依赖关系
  providers: [
    // 工厂模式, TestService1和TestService2产生关联,
    TestService1,
    {
      provide: "test1",
      inject: [TestService1], // 将TestService1注入到工厂函数
      useFactory(TestService1: TestService1) {
        console.log(TestService1.create("TestService1"), 222222222);
        const TestService1Value = TestService1.create("TestService1");
        return new TestService2(TestService1Value);
      },
    },
    // 工厂模式 useFactory的异步形式
    {
      provide: "useFactoryAsync",
      async useFactory() {
        return await new Promise((resolve) => {
          setTimeout(() => {
            resolve("我是工厂函数的异步形式");
          }, 2000);
        });
      },
    },
  ],
})
export class AppModule {}
```

3. 使用，在`test.controller.ts`中注入依赖并使用

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Inject,
} from "@nestjs/common";
import { TestService } from "./test.service";
import { CreateTestDto } from "./dto/create-test.dto";
import { UpdateTestDto } from "./dto/update-test.dto";

@Controller("test")
export class TestController {
  // 自定义名称注入依赖，通过 @Inject(在app.module.ts中所自定义的名称)，通过该名称确定依赖关系
  constructor(
    @Inject("test1") private readonly test1: any,
    @Inject("useFactoryAsync") private readonly useFactoryAsync: string
  ) {
    // 通过TestService1 注入到 test1，返回TestService2, 最后影响TestService2 也就是test1
    console.log(this.test1?.create());
    console.log(this.useFactoryAsync);
  }
}
```
