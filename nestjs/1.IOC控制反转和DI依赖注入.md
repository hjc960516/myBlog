## IOC 控制反转和 DI 依赖注入

控制反转（Inversion of Control，IoC）和依赖注入（Dependency Injection，DI）是软件开发中常用的设计模式和技术，用于解耦和管理组件之间的依赖关系。 虽然它们经常一起使用，但它们是不同的概念

### IOC 控制反转

控制反转（IoC）是一种设计原则，它将组件的控制权从组件自身转移到外部容器。 传统上，组件负责自己的创建和管理，而控制反转则将这个责任转给了一个外部的容器或框架。 容器负责创建组件实例并管理它们的生命周期，组件只需声明自己所需的依赖关系，并通过容器获取这些依赖。这种反转的控制权使得组件更加松耦合、可测试和可维护

### DI 依赖注入

依赖注入（DI）是实现控制反转的一种具体技术。 它通过将组件的依赖关系从组件内部移动到外部容器来实现松耦合。 组件不再负责创建或管理它所依赖的其他组件，而是通过构造函数、属性或方法参数等方式将依赖关系注入到组件中。 依赖注入可以通过构造函数注入（Constructor Injection）、属性注入（Property Injection）或方法注入（Method Injection）等方式实现

## 代码说明

### 普通类型

没有`IOC控制反转`和`DI依赖注入`时，我们会发现，A 类和 C 类有很强的依赖关系，我们创建的 C 类数据中，像这种依赖的关系，如果我们有大量的数据需要彼此之间的数据依赖，
会发现很难维护，牵一动百，维护成本和开发难度都会几何级别的增长

```ts
/**
 * 无IOC控制反转和DI依赖注入时
 */
class A {
  name: any;
  constructor(value: any) {
    this.name = value;
  }
}

// C引用A的name
class C {
  name: any;
  age: number;
  constructor(age: number) {
    this.name = new A("我是A类");
    this.age = age;
  }
}

// 实例化C
const c = new C(18);

// 获取c的name时，发现C中是依赖A的，耦合度很高，多代码或者多类时，会很麻烦，修改多处，彼此耦合
c.name;
```

### 增加 IOC 和 DI

`IOC反转控制`和`DI依赖注入`的实际思想是: 通过一个`中间件`将彼此的`耦合度解开`，放在一个容器中存储来搜集依赖，通过该中间件去注入到所需要的数据中，减少维护成本和开发难度

```ts
/**
 * ----------------------------------------------------------------------------
 * IOC反转控制和DI依赖注入
 * 实际是通过一个中间件将彼此的耦合度解开，放在一个容器中存储来搜集依赖，通过该中间件去注入到所需要的数据中
 */

class AA {
  name: any;
  constructor(name: any) {
    this.name = name;
  }
}

class CC {
  age: number;
  constructor(age: number) {
    this.age = age;
  }
}

// 该容器存储，用于解耦和搜集依赖, 类似map的映射表
class Container {
  modules: any;
  constructor() {
    this.modules = {};
  }
  // 注入
  provide(key: string, module: any) {
    this.modules[key] = module;
  }
  // 获取
  get(key: string) {
    return this.modules[key];
  }
}

// 此时将AA和CC注入到容器中，解耦，彼此没有关联
const modules = new Container();
modules.provide("aa", new AA("我是AA"));
modules.provide("cc", new CC(18));

// 创建需要的类，并且将所需要的类引用
class BB {
  aa: any;
  cc: number;
  // 注入容器依赖
  constructor(container: Container) {
    this.aa = container.get("aa");
    this.cc = container.get("cc");
  }
}

// 将中间件容器注入
const bb = new BB(modules);

console.log(bb.aa.name);
```
