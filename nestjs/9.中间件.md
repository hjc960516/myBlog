## 中间件

中间件是在路由处理程序之前调用的函数。中间件函数可以访问 request 和 response 对象，以及应用请求-响应周期中的 next() 中间件函数。下一个中间件函数通常由名为 next 的变量表示
默认情况下，Nest 中间件等同于 express 中间件。
中间件是在路由处理程序 之前 调用的函数。 中间件函数可以访问请求和响应对象

### 中间件可执行任务

1. 执行任何代码
2. 对请求和响应对象进行更改
3. 结束请求-响应周期
4. 调用堆栈中的下一个中间件函数
5. 如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起

### 依赖注入

Nest 中间件完全支持依赖注入。就像提供器和控制器一样，它们能够注入同一模块中可用的依赖。像往常一样，这是通过 constructor 完成的

## 局部使用中间件

限制部分指定路由使用中间件

### 创建一个中间件

中间件也是通过`@Injectable装饰类`来注入, 类似`xxx.service.ts` 中 注入服务一样,
通过`ts的implements`来限制接口规范,也就是`NestMiddleware`的规范

```ts
import { Injectable, NestMiddleware } from "@nestjs/common";
import { Request, Response, NextFunction } from "express";

// 中间件也是通过@Injectable装饰类来注入, 类似xxx.service.ts 中 注入服务一样
@Injectable()
// 通过`ts的implements`来限制接口规范,也就是`NestMiddleware`的规范
export class LoggerMiddkeware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log(`当前请求方法是${req.method},当前请求地址是${req.url}`);
    // 必须调用next()执行下一个,否则请求会被挂起
    next();
  }
}
```

### 创建一个 CURD 模式

```sh
nest g res cats
```

### 使用中间件

中间件在使用时可以有多种现在和操作，例如`注册多个中间件`、`不通过某些路由`、`指定某些路由的指定方法`等等

```ts app.module.ts
import {
  MiddlewareConsumer,
  Module,
  NestModule,
  RequestMethod,
} from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { LoggerMiddkeware } from "./middleware/logger.middleware";
import { CatsModule } from "./cats/cats.module";
import { CatsController } from "./cats/cats.controller";

@Module({
  imports: [CatsModule],
  controllers: [AppController],
  providers: [AppService],
})
// 通过 NestModule 来限制 AppModule 的规范
export class AppModule implements NestModule {
  // configure(consumer: MiddlewareConsumer) 函数 必须加的的规范，也就是 NestModule 通过该函数来限制和注册中间件
  // 通过返回的 consumer消费者 来处理中间件
  configure(consumer: MiddlewareConsumer) {
    consumer
      /**
       * apply: 注册路由
       * 注册中间件，可多个 .apply(xxx,xxx,xxx,....)
       *
       */
      .apply(LoggerMiddkeware)
      /**
       * exclude 排除路由
       * exclude({path: 'xxxx', method: RequestMethod.ALL}) 可以排除一个或多个路由, 同样可以指定路由的某个方法
       * exclude('exclude-all/*') 也可以使用匹配规则，exclude-all/*表示匹配 exclude-all/任何东西， * 通配符，表示匹配所有
       */
      .exclude({ path: "exclude", method: RequestMethod.ALL }, "exclude-all/*")
      /**
       * forRoutes: 指定路由
       * forRoutes('') 指定路由执行该中间件, 不指定不执行，'' 表示指定的是 / 根路由
       * forRoutes({ path: 'cats', method: RequestMethod.GET })  也可以指定请求方法
       * forRoutes(CatsController)  也可以直接把Controller塞进去
       * forRoutes({   也可以使用匹配规则，cats/*表示匹配 cats/任何东西， * 通配符，表示匹配所有
          path: 'cats/*',
          method: RequestMethod.ALL
        })
       */
      // .forRoutes('')
      // .forRoutes({ path: 'cats', method: RequestMethod.GET })
      // .forRoutes(CatsController)
      .forRoutes({
        path: "cats/*",
        method: RequestMethod.ALL,
      });
  }
}
```

## 全局中间件

所有请求都经过该中间件, 必须通过`函数`创建, 和`express`一样通过`use`来注册

### 编写中间件

```ts
import { Request, Response, NextFunction } from "express";

export function globalMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
) {
  console.log(`我是全局中间件，坤坤们都得听我指挥！！！`);

  next();
}
```

### 使用

::: warning

和`express`一样，是使用`use`来注册全局组件，是在`main.ts`中注册

:::

```ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import { globalMiddleware } from "./middleware/global.middleware";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.use(globalMiddleware); // 注册全局中间件, 第三方中间件也是同样注册方法，例如cros()跨域中间件
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```
