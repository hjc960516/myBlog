# 脚手架(nestjs cli) 和 RESTful 风格设计

## 脚手架(nestjs cli)

类似`vue脚手架`,`vite`一样，可以快速创建项目

1. 安装

```sh
# 全局安装脚手架
npm i @nestjs/cli -g

# 查看安装版本
nest --version
```

2. 通过脚手架安装项目

```sh
nest new [项目名称]
```

3. 启动项目

```sh
# 和node一样，通过 package.json 去修改命令
npm [配置的启动命令]
```

### 使用脚手架安装项目

:::warning 注意事项
如果遇到一直无法安装依赖，显示依赖版本冲突，有可能是因为`有缓存以前版本的root文件`, mac 可以执行`sudo chown -R 501:20 "/Users/hello/.npm"`来赋值权限
:::

```sh
# 执行该命令会自动安装依赖
nest new test-project

# 启动项目 start:dev 热启动  start 普通启动
npm run start:dev
```

#### 目录解析

- src/
  - app.controller.spec.ts
  - app.controller.ts
  - app.module.ts
  - app.service.ts
  - main.ts

##### main.ts

入口文件，类似`vue的main.ts入口文件`

```ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
  // 通过NestFactory.create()创建实例，类似express的express()
  // AppModule 类似vue的 app.vue 根组件
  const app = await NestFactory.create(AppModule);
  // 启动服务，并监听端口
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```

##### app.controller.ts

路由，类似`vue的router`和`express的app.use(前置路径,路由模块文件)`,用来控制请求的路径

```ts
import { Controller, Get } from "@nestjs/common";
import { AppService } from "./app.service";

// app.Controller.ts 相当于 路由，类似vue的router
// 未修改的路由, 通过访问http://localhost:3000 直接访问，得到app.service.ts中的 getHello 返回的数据
@Controller()
export class AppController {
  // 依赖注入AppService， 内部会自动实例化
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

// 也可以修改访问路由, 通过访问http://localhost:3000/getList/list 直接访问，得到app.service.ts中的 getList 返回的数据
// 注意1: appServer.getList()，需要在app.service.ts中自己写一个函数
// 注意2: 因为是新写的路由 AppControllerList ，需要再app.module.ts中，注入 AppControllerList
@Controller("/getList")
export class AppControllerList {
  constructor(private readonly appServer: AppService) {}
  @Get("/list")
  getList(): any[] {
    return this.appServer.getList();
  }
}
```

##### app.service.ts

这个文件主要实现业务逻辑的 当然 Controller 可以实现逻辑，但是就是单一的无法复用，放到 app.service 有别的模块也需要就可以实现复用

```ts
import { Injectable } from "@nestjs/common";

// 复用模块，可通过注入实现通用
@Injectable()
export class AppService {
  getHello(): string {
    return "Hello World!";
  }
  getList(): any[] {
    return [
      {
        title: "test",
      },
    ];
  }
}
```

##### app.module.ts

根 module，类似`vue中的app.vue`

```ts
import { Module } from "@nestjs/common";
import { AppController, AppControllerList } from "./app.controller";
import { AppService } from "./app.service";

@Module({
  // 导入第三方
  imports: [],
  // 注入路由
  controllers: [AppController, AppControllerList],
  // 注入通用模块
  providers: [AppService],
})
export class AppModule {}
```

### 常用命令

如果你用过`angular`，你会发现`nest`的命令很多都是参考`angular-cli`的命令

#### 查看所有命令

```sh
nest --help
```

#### 单个生成文件

1. 生成 controller.ts

```sh
nest g co user
```

2. 生成 module.ts

```sh
nest g mo user
```

3. 生成 service.ts

```sh
nest g s user
```

#### 一键生成 CURD 模板

单个生成，你会发现很麻烦，不像 `ng-cli` 的常用一键生成一样，其实也是有的,
使用`CURD模板`生成，会省去后续更新，会自动导入注入依赖，
第一次使用这个命令的时候，除了生成文件之外还会自动使用 npm 帮我们更新资源，安装一些额外的插件，后续再次使用就不会更新了

```sh
nest g resource test
```

## RESTful 风格设计

`RESTful` 是一种`风格`, 在 RESTful 中, 一切都被认为是资源，每个资源有对应的 URL 标识, 不是标准也不是协议，只是一种风格。

### RESTful 接口

RESTful 风格一个接口就会完成 增删改差 他是通过不同的请求方式来区分的

- 查询 GET
- 提交 POST
- 更新 PUT PATCH
- 删除 DELETE

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from "@nestjs/common";
import { TestService } from "./test.service";
import { CreateTestDto } from "./dto/create-test.dto";
import { UpdateTestDto } from "./dto/update-test.dto";

@Controller("test")
export class TestController {
  constructor(private readonly testService: TestService) {}

  @Post()
  create(@Body() createTestDto: CreateTestDto) {
    return this.testService.create(createTestDto);
  }

  @Get()
  findAll() {
    return this.testService.findAll();
  }

  @Get(":id")
  findOne(@Param("id") id: string) {
    return this.testService.findOne(+id);
  }

  @Patch(":id")
  update(@Param("id") id: string, @Body() updateTestDto: UpdateTestDto) {
    return this.testService.update(+id, updateTestDto);
  }

  @Delete(":id")
  remove(@Param("id") id: string) {
    return this.testService.remove(+id);
  }
}
```

### RESTful 版本控制

一共有`三种`我们一般用`第一种` 更加语义化

1. URI Versioning
   版本将在请求的 URI 中传递（默认）
2. Header Versioning
   自定义请求标头将指定版本
3. Media Type Versioning
   请求的 Accept 标头将指定版本

#### URI Versioning 版本控制

```ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import { VersioningType } from "@nestjs/common";

async function bootstrap() {
  // 通过NestFactory.create()创建实例，类似express的express()
  // AppModule 类似vue的 app.vue 根组件
  const app = await NestFactory.create(AppModule);
  // 添加版本uri控制
  app.enableVersioning({
    type: VersioningType.URI,
  });
  // 启动服务，并监听端口
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```

#### controller 添加版本控制

访问时，需要指定版本, 例如 `http://localhost:3000/v1/test`

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from "@nestjs/common";
import { TestService } from "./test.service";
import { CreateTestDto } from "./dto/create-test.dto";
import { UpdateTestDto } from "./dto/update-test.dto";

// 将Controller通过对象形式进行配置
@Controller({
  path: "test",
  version: "1",
})
export class TestController {
  constructor(private readonly testService: TestService) {}

  @Post()
  create(@Body() createTestDto: CreateTestDto) {
    return this.testService.create(createTestDto);
  }

  @Get()
  findAll() {
    return this.testService.findAll();
  }

  @Get(":id")
  findOne(@Param("id") id: string) {
    return this.testService.findOne(+id);
  }

  @Patch(":id")
  update(@Param("id") id: string, @Body() updateTestDto: UpdateTestDto) {
    return this.testService.update(+id, updateTestDto);
  }

  @Delete(":id")
  remove(@Param("id") id: string) {
    return this.testService.remove(+id);
  }
}
```

#### Code 码规范

- 200 OK
- 304 Not Modified 协商缓存了
- 400 Bad Request 参数错误
- 401 Unauthorized token 错误
- 403 Forbidden referer origin 验证失败
- 404 Not Found 接口不存在
- 500 Internal Server Error 服务端错误
- 502 Bad Gateway 上游接口有问题或者服务器问题
