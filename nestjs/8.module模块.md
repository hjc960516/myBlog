## 模块

模块是用 `@Module()` 装饰器注释的类。`@Module()` 装饰器提供 Nest 用于组织应用结构的元数据。
每个应用至少有一个模块，即根模块。根模块是 Nest 用于构建应用图的起点 - Nest 用于解析模块和提供器关系及依赖的内部数据结构。
虽然非常小的应用理论上可能只有根模块，但这不是典型的情况。我们要强调的是，强烈建议将模块作为组织组件的有效方式。
因此，对于大多数应用来说，最终的架构将采用多个模块，每个模块封装一组密切相关的功能。

|  配置属性   |                                                        解析                                                         |
| :---------: | :-----------------------------------------------------------------------------------------------------------------: |
|  providers  |                             将由 Nest 注入器实例化并且至少可以在该模块中共享的提供程序                              |
| controllers |                                         此模块中定义的必须实例化的控制器集                                          |
|   imports   |                                       导出此模块所需的提供程序的导入模块列表                                        |
|   exports   | 这个模块提供的 providers 的子集应该在导入这个模块的其他模块中可用。你可以使用提供器本身或仅使用其令牌（provide 值） |

### 功能模块

1. 创建一个测试 module
   需要注意执行命令的位置

```sh
# 创建module，会自动把创建的module导入app.module中
nest g mo user
```

2. 新建`cats.service.ts`和`cats.controller.ts`,并导入`cats.module.ts`

- cats.service.ts

```ts cats.service.ts
import { Injectable } from "@nestjs/common";
// 注入器
@Injectable()
export class CatsService {
  constructor() {}
  getName(): string {
    return "catsService模块";
  }
}
```

- cats.controller.ts

```ts cats.controller.ts
import { Controller } from "@nestjs/common";
import { CatsService } from "./cats.service";

@Controller("/cats")
export class CatsController {
  // 注入依赖
  constructor(private readonly catsService: CatsService) {
    console.log(this.catsService.getName());
  }
}
```

- cats.module.ts

```ts cats.module.ts
import { Module } from "@nestjs/common";
import { CatsService } from "./cats.service";
import { CatsController } from "./cats.controller";

@Module({
  providers: [CatsService], // 注入依赖并实例化，才可在CatsController使用
  controllers: [CatsController], // 注入CatsController
})
export class CatsModule {}
```

### 共享模块

只需要配置`exports`,那么每个导入`catsModule`模块的，都可以共享`CatsService`，也可以将其导入到`app.module.ts`的根 module 中，这样所有的 module 都可以共享`CatsService`

- `catsModule`模块

```ts cats.module.ts
import { Module } from "@nestjs/common";
import { CatsService } from "./cats.service";
import { CatsController } from "./cats.controller";

@Module({
  providers: [CatsService], // 注入依赖并实例化，才可在CatsController使用
  controllers: [CatsController], // 注入CatsController
  exports: [CatsService], // 将CatsService导入，那么导入CatsModule模块会自动把CatsService共享到其中
})
export class CatsModule {}
```

- app.module.ts

```ts app.module.ts
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { TestModule } from "./test/test.module";
import { CatsModule } from "./cats/cats.module";
import { CatsService } from "./cats/cats.service";

@Module({
  // CatsModule使用命令创建会自动导入，如果不是需要自己导入,会自动把service和controller注入
  imports: [TestModule, CatsModule],
  controllers: [AppController],
  providers: [AppService, CatsService], // CatsService注入根module，这样所有的模块都可以共享CatsService
})
export class AppModule {}
```

### 全局模块

与 Nest 不同，`Angular providers` 是在`全局作用域内`注册的。
一旦定义，它们`随处可用`。然而，Nest 将提供程序封装在`模块作用域内`。如果`不首先导入封装模块`，则`无法`在其他地方使用模块的提供程序。
当你想要提供一组开箱即用的提供程序（例如辅助程序、数据库连接等）时，请使用` @Global() 装饰器`使模块`全局化`。
`@Global() 装饰器`使模块具有全局作用域。全局模块应该`只注册一次`，通常由根模块或核心模块注册。

1. 新建`glo`模块

```sh
nest g res glo
```

2. 将`glo`模块设置为`全局模块`

```ts glo.module.ts
import { Module, Global } from "@nestjs/common";
import { GloService } from "./glo.service";
import { GloController } from "./glo.controller";

@Global() // 将GloModule设置为全局模块
@Module({
  controllers: [GloController],
  providers: [GloService],
  exports: [GloService],
})
export class GloModule {}
```

3. 在任意模块注入使用`GloService`, 例如: `cats.controller.ts`

```ts cats.controller.ts
import { Controller } from "@nestjs/common";
import { CatsService } from "./cats.service";
import { GloService } from "../glo/glo.service";

@Controller("/cats")
export class CatsController {
  // 注入依赖
  // GloService 全局注入的依赖模块
  constructor(
    private readonly catsService: CatsService,
    private readonly GloService: GloService
  ) {
    console.log(this.catsService.getName());
    console.log(this.GloService.findAll());
  }
}
```

### 动态加载 module

动态模块主要就是为了给模块传递参数 可以给该模块添加一个静态方法 用来接受参数

1. 新建`dynamic`模块

```sh
nest g res dynamic
```

2. 添加动态方法

```ts dynamic.module
import { Module, DynamicModule, Global } from "@nestjs/common";
import { DynamicService } from "./dynamic.service";
import { DynamicController } from "./dynamic.controller";

// 动态module
@Module({})
export class DynamicsModule {
  // 添加静态方法
  static forRoot(): DynamicModule {
    return {
      module: DynamicsModule,
      providers: [DynamicService],
      controllers: [DynamicController],
    };
  }
}

// 动态module，可添加参数
// @Global()
@Module({})
export class DynamicsGlobalModule {
  // 也可以传参
  static getPath(options: { path: string }): DynamicModule {
    const provider = {
      provide: "Config",
      useValue: { basePath: "/api" + options.path },
    };
    return {
      module: DynamicsGlobalModule,
      providers: [provider],
      exports: [provider],
    };
  }
}
```

3. 在`app.module.ts`中添加`不是自定义值的`依赖

```ts
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { TestModule } from "./test/test.module";
import { CatsModule } from "./cats/cats.module";
import { CatsService } from "./cats/cats.service";
import { GloModule } from "./glo/glo.module";
import { DynamicsModule, DynamicsGlobalModule } from "./dynamic/dynamic.module";

@Module({
  // CatsModule使用命令创建会自动导入，如果不是需要自己导入,会自动把service和controller注入
  // 动态加载module, DynamicsModule
  imports: [
    TestModule,
    CatsModule,
    GloModule,
    DynamicsModule.forRoot(),
    DynamicsGlobalModule.getPath({ path: "baseUrl" }),
  ],
  controllers: [AppController],
  providers: [AppService, CatsService], // CatsService注入根module，这样所有的模块都可以共享CatsService
})
export class AppModule {}
```

4. 在需要添加的模块中添加`自定义值得Config模块`

```ts
import { Module } from "@nestjs/common";
import { CatsService } from "./cats.service";
import { CatsController } from "./cats.controller";
import { DynamicsGlobalModule } from "../dynamic/dynamic.module";

@Module({
  imports: [DynamicsGlobalModule.getPath({ path: "base" })],
  providers: [CatsService], // 注入依赖并实例化，才可在CatsController使用
  controllers: [CatsController], // 注入CatsController
  exports: [CatsService], // 将CatsService导入，那么导入CatsModule模块会自动把CatsService共享到其中
})
export class CatsModule {}
```

5. 应用`自定义值得Config模块`

```ts
import { Controller, Inject } from "@nestjs/common";
import { CatsService } from "./cats.service";
import { GloService } from "../glo/glo.service";

@Controller("/cats")
export class CatsController {
  // 注入依赖
  // GloService 全局注入的依赖模块
  constructor(
    private readonly catsService: CatsService,
    private readonly GloService: GloService,
    @Inject("Config") private readonly Config: { basePath: string } // 动态module注入的自定义值module
  ) {
    console.log(this.catsService.getName());
    console.log(this.GloService.findAll());
    console.log(this.Config);
  }
}
```

6. 如果是公共模块的，请打开`dynamic.module`中的`@Global`设为全局引入，并在`app.module`中注入
