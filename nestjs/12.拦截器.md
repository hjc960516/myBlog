## 拦截器

拦截器是用 `@Injectable()` 装饰器注释并实现 `NestInterceptor` 接口的类。
拦截器具有一组有用的功能，这些功能的灵感来自 面向方面编程 (AOP) 技术。它们可以：

- 在方法执行之前/之后绑定额外的逻辑
- 转换函数返回的结果
- 转换函数抛出的异常
- 扩展基本功能行为
- 根据特定条件完全覆盖函数（例如，出于缓存目的）

### 基本

每个拦截器都实现了 `intercept()` 方法，它有两个参数。第一个是 `ExecutionContext` 实例（与 guards 完全相同的对象）。
`ExecutionContext` 继承自 `ArgumentsHost`。

### response 拦截器

在`common/response`中编写

```ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from "@nestjs/common";
import { HttpArgumentsHost } from "@nestjs/common/interfaces";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";

interface data<T> {
  data: T;
}
/**
 * 规范返回数据的格式, 在main.ts中使用 app.useGlobalInterceptors(new Response())注册使用
 */
@Injectable()
export class Response<T = any> implements NestInterceptor {
  /**
   *
   * @param context 上下文
   * @param next Observable
   * @returns Observable<T> || Promise<Observable<T>>
   */
  intercept(
    context: ExecutionContext,
    next: CallHandler<any>
  ): Observable<data<T>> | Promise<Observable<data<T>>> {
    // 获取 HTTP 上下文
    const httpContext: HttpArgumentsHost = context.switchToHttp();
    // 获取响应对象
    const response = httpContext.getResponse();
    // 获取响应的 statusCode
    const statusCode = response.statusCode;
    // data: response返回的数据
    return next.handle().pipe(
      map((data) => {
        return {
          data,
          status: statusCode,
          success: statusCode >= 200 && statusCode < 300,
          msg: statusCode >= 200 && statusCode < 300 ? "请求成功" : "请求失败",
        };
      })
    );
  }
}
```

#### 注册使用 response 拦截器

在`main.ts`中使用 `app.useGlobalInterceptors(new Response())`进行注册, 这样每个请求都会经过该中间件，然后会把返回数据规范化

```ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import { Response } from "../common/respone";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  // 注册response拦截器
  app.useGlobalInterceptors(new Response());
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```

### 异常拦截器

在`common/exception`中编写

```ts
import {
  ExceptionFilter,
  HttpException,
  Catch,
  ArgumentsHost,
} from "@nestjs/common";
import { Request, Response } from "express";

/**
 * 异常拦截器
 * 在main.ts中使用 app.useGlobalFilters(new ExceptionObserver())注册使用
 */
@Catch(HttpException)
export class ExceptionObserver implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    // 获取 HTTP 上下文
    const httpContext = host.switchToHttp();
    // 获取响应对象
    const response = httpContext.getResponse<Response>();
    // 获取请求对象
    const request = httpContext.getRequest<Request>();
    // 响应状态码
    const status = exception.getStatus();

    // 异常时，返回异常数据信息
    response.status(status).json({
      data: exception.message, // 异常原因
      time: new Date().getTime(), // 异常时间
      success: false, // 请求成功与否
      path: request.url, // 请求方法
      status, // 响应码
    });
  }
}
```

#### 使用异常拦截器

在`main.ts`中使用 `app.useGlobalFilters(new ExceptionObserver())`注册使用

:::warning 注意
`response拦截器`是使用的`useGlobalInterceptors`来注册, 而`异常拦截器`是使用`useGlobalFilters`来注册
:::

```ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import { Response } from "../common/respone";
import { ExceptionObserver } from "../common/exception";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  // 注册response拦截器
  app.useGlobalInterceptors(new Response());
  // 注册异常拦截器
  app.useGlobalFilters(new ExceptionObserver());
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```
