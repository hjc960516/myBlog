## 爬虫

其实爬虫是一个对计算机综合能力要求比较高的技术活。
首先是要对网络协议尤其是 http 协议有基本的了解, 能够分析网站的数据请求响应。学会使用一些工具，简单的情况使用 chrome devtools 的 network 面板就够了

### 依赖

- cheerio: 是 jquery 核心功能的一个快速灵活而又简洁的实现，主要是为了用在服务器端需要对 DOM 进行操作的地方，让你在服务器端和 html 愉快的玩耍
- axios: 网络请求库可以发送 http 请求

### 新建项目

```sh
nest new test

# 安装依赖
# axios 发送请求库
# cheerio jq在服务器端操作dom库
npm i axios cheerio

```

### 编写代码

当前例子只拿了 11 张图片写入当前项目文件夹中，如果需要爬取所有，请自行用已经准备的参数写入其他逻辑

:::warning 注意事项

1. `tsconfig.json`中，如果没打开`esModuleInterop: true`选项,请把`import path from "node:path"` 改为 `import * as path from "node:path"`, 其他 `node模块`也一样

2. 需要提前建好存储图片的文件夹

:::

```ts
// app.controller.ts

import { Controller, Get, Query } from "@nestjs/common";
import { AppService } from "./app.service";
import * as cheerio from "cheerio";
import axios from "axios";
import path from "node:path";
import fs from "node:fs";

/**
 * 写入本地
 * @param urls
 */
const writeFile = async (urls: string[]) => {
  for await (const url of urls) {
    try {
      const buffer = await axios
        .get(url, { responseType: "arraybuffer" })
        .then((res) => res.data);
      const imgPath = path.join(
        __dirname,
        "../images",
        "img" + new Date().getTime() + ".jpg"
      );
      const ws = fs.createWriteStream(imgPath);
      ws.write(buffer);
      ws.end();
    } catch (error) {
      console.log("当前图片写入出错----------", url);
      continue;
    }
  }
};

@Controller()
export class AppController {
  index: number = 1; // 当前页
  hasNext: boolean = false; // 是否为最后一页
  maxPage: number | string = 1; // 是否为最大的页
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get("/img")
  async getIma(@Query("page") page) {
    const that = this;
    let index = page;
    if (index > that.maxPage) {
      index = that.maxPage;
    }
    let url = `https://stock.tuchong.com/topics?goods_type=0${
      index > 1 ? `&page=${index}` : ""
    }`;
    try {
      const res = await axios.get(url);
      // 加载页面
      const $ = cheerio.load(res.data);
      // 获取最后一页
      const maxPage = $(".el-pager li").last().text();
      that.index = index;
      that.maxPage = maxPage;
      // 判断下一页是否可点击，也就是是否是最后一页
      const nextBtn = $(".btn-next").each(function (index, el) {
        const disable = $(this).attr("disabled");
        that.hasNext = !disable;
      });
      // 获取当前页所有的图片地址
      const imgArr: string[] = [];
      const imgs = $(".topic-card__image img").each(function (index, el) {
        // 获取img标签的url链接地址
        const imgurl = $(this).attr("src");
        if (imgurl) {
          imgArr.push(imgurl?.startsWith("//") ? `https:${imgurl}` : imgurl);
        }
      });

      if (imgArr.length > 10) {
        writeFile(imgArr.filter((value, index) => index <= 11));
      }

      return {
        code: 200,
        msg: "爬取当前页成功",
        currentPage: index,
        images: imgArr,
      };
    } catch (error) {
      return {
        code: 400,
        msg: "爬取失败",
        err: error,
      };
    }
  }
}
```
