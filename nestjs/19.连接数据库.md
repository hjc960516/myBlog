## 数据库

Nest 与数据库无关，使你可以轻松地与任何 SQL 或 NoSQL 数据库集成。根据你的喜好，你有多种选择。
在最一般的层面上，将 Nest 连接到数据库只是为数据库加载适当的 Node.js 驱动程序的问题，就像使用 Express 或 Fastify 一样。
你还可以直接使用任何通用 Node.js 数据库集成库或 ORM。

## mysql

Nestjs 集成数据库，由于企业用的 Mysql 居多 我们就用 Nestjs 连接 Mysql。

### 安装 MySQL

因为之前在写`nodejs`的时候已经详细介绍过`mysql`的安装和操作等基本知识,这里就不过多叙述。
详情请移步到我的 blog 中的[`MySQL模块`](https://hjc960516.github.io/myBlog/node/mysql/)

### ORM 框架集成(typeorm)

[`TypeORM中文文档`](https://typeorm.biunav.com/zh/#%E5%AE%89%E8%A3%85),
为了与 SQL 和 NoSQL 数据库集成，Nest 提供了 `@nestjs/typeorm` 包。
`TypeORM` 是可用于 `TypeScript` 的最成熟的`对象关系映射器 (ORM)`。
由于它是用 TypeScript 编写的，因此可以很好地与 Nest 框架集成。

### 安装依赖

```sh
npm install --save @nestjs/typeorm typeorm mysql2
```

### 连接

在`app.module.ts`中，通过`TypeOrmModule.forRoot`进行注入

```ts
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { TypeOrmModule } from "@nestjs/typeorm"; // orm数据库集成
import { UserModule } from "./user/user.module";

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: "mysql", // 数据库类型
      database: "nestjs", // 数据库名称
      host: "127.0.0.1", // 数据库地址
      port: 3306, // 数据库端口
      username: "root", // 数据库账号
      password: "123456", // 数据库密码
      entities: [__dirname + "/**/*.entity{.ts,.js}"], // 实体文件, 也就是使用@Entity()装饰器注入的文件
      synchronize: true, // synchronize字段代表是否自动将实体类同步到数据库
      retryDelay: 500, // 重试连接数据库间隔
      retryAttempts: 10, // 重试连接数据库的次数
      autoLoadEntities: true, // 如果为true,将自动加载实体 forFeature()方法注册的每个实体都将自动添加到配置对象的实体数组中
    }),
    UserModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

### 创建表

创建一个`xxx.entity.[ts|js]`文件，因为在`TypeOrmModule.forRoot`中的`entities`使用了自动导入实体文件

```ts
import { Entity, Column, PrimaryGeneratedColumn, Generated } from "typeorm";

@Entity()
export class User {
  // 自增列, 也可以设置为 uuid 的主列
  // @PrimaryGeneratedColumn()
  @PrimaryGeneratedColumn("uuid")
  id: number;

  // 自动生成的列
  // @Generated
  @Generated("uuid")
  uuid: string;

  // 普通列, 也可以主动设置类型等
  // @Column()
  @Column({ type: "varchar", length: 288 })
  name: string;

  // default: 默认值
  @Column({ type: "boolean", default: true })
  is_member: boolean;

  // 枚举
  @Column({ type: "enum", enum: ["男", "女"], default: "男" })
  sex: string;

  // 数组类型，存进数据库时，会以 , 隔开
  @Column("simple-array")
  hobboy: string[];

  // json类型, 它可以存储任何可以通过 JSON.stringify 存储在数据库中的值
  @Column("simple-json")
  profile: { name: string; nickname: string };
}
```

### 使用

1. 在目标模块的`xxx.module.ts`中通过`TypeOrmModule.forFeature([...entity])`注入到目标模块
2. 在`xxx.[service | controller].ts`中通过`InjectRepository`注入

```ts
// user.module.ts

import { Module } from "@nestjs/common";
import { UserService } from "./user.service";
import { UserController } from "./user.controller";
import { TypeOrmModule } from "@nestjs/typeorm";
import { User } from "../entities/user.entity";

@Module({
  // 将数据库表实体文件通过 TypeOrmModule.forFeature([...entity]) 注入到目标模块
  imports: [TypeOrmModule.forFeature([User])],
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}
```

```ts
// user.service.ts

import { Injectable } from "@nestjs/common";
import { CreateUserDto } from "./dto/create-user.dto";
import { UpdateUserDto } from "./dto/update-user.dto";
import { User } from "../entities/user.entity";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";

@Injectable()
export class UserService {
  constructor(
    // 将 User 注入到 class中
    @InjectRepository(User)
    private usersRepository: Repository<User>
  ) {}

  create(createUserDto: CreateUserDto) {
    return "This action adds a new user";
  }

  update(id: number, updateUserDto: UpdateUserDto) {
    return `This action updates a #${id} user`;
  }

  findAll(): Promise<User[]> {
    return this.usersRepository.find(); // 查询所有
  }

  findOne(id: number): Promise<User | null> {
    return this.usersRepository.findOneBy({ id }); // 通过id查询单一
  }

  async remove(id: number): Promise<void> {
    await this.usersRepository.delete(id); // 删除单个
  }
}
```

## 实体

上面说到的实体到底是什么呢?
实体是一个映射到数据库表的类。 你可以通过定义一个新类来创建一个实体，并用`@Entity()`来标记

```ts
import { Entity, Column, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class User {
  // 自增列
  @PrimaryGeneratedColumn()
  id: number;

  // 普通列
  @Column()
  name: string;

  // default: 默认值
  @Column({ default: true })
  is_member: boolean;
}
```

### 常用装饰器和配置

创建数据库列和列配置

```ts
import { Entity, Column, PrimaryGeneratedColumn, Generated } from "typeorm";

@Entity()
export class User {
  // 自增列, 也可以设置为 uuid 的主列
  // @PrimaryGeneratedColumn()
  @PrimaryGeneratedColumn("uuid")
  id: number;

  // 自动生成的列
  // @Generated
  @Generated("uuid")
  uuid: string;

  // 普通列, 也可以主动设置类型等
  // @Column()
  @Column({ type: "varchar", length: 288 })
  name: string;

  // default: 默认值
  @Column({ type: "boolean", default: true })
  is_member: boolean;

  // 枚举
  @Column({ type: "enum", enum: ["男", "女"], default: "男" })
  sex: string;

  // 数组类型，存进数据库时，会以 , 隔开
  @Column("simple-array")
  hobboy: string[];

  // json类型, 它可以存储任何可以通过 JSON.stringify 存储在数据库中的值
  @Column("simple-json")
  profile: { name: string; nickname: string };
}
```

### column 装饰器常用配置

```ts
@Column({
    type:"varchar",
    name:"ipaaa", //数据库表中的列名
    nullable:true, //在数据库中使列NULL或NOT NULL。 默认情况下，列是nullable：false
    comment:"注释",
    select:true,  //定义在进行查询时是否默认隐藏此列。 设置为false时，列数据不会显示标准查询。 默认情况下，列是select：true
    default:"xxxx", //加数据库级列的DEFAULT值
    primary:false, //将列标记为主要列。 使用方式和@ PrimaryColumn相同。
    update:true, //指示"save"操作是否更新列值。如果为false，则只能在第一次插入对象时编写该值。 默认值为"true"
    collation:"", //定义列排序规则。
})
```

### ColumnOptions 中可用选项列表：

- `type: ColumnType` - 列类型。其中之一在上面。
- `name: string` - 数据库表中的列名。默认情况下，列名称是从属性的名称生成的。 你也可以通过指定自己的名称来更改它。
- `length: number` - 列类型的长度。 例如，如果要创建 varchar（150）类型，请指定列类型和长度选项。
- `width: number` - 列类型的显示范围。 仅用于 MySQL integer types(opens new window)
- `onUpdate: string` - ON UPDATE 触发器。 仅用于 MySQL (opens new window).
- `nullable: boolean` - 在数据库中使列 NULL 或 NOT NULL。 默认情况下，列是 nullable：false。
- `update: boolean` - 指示"save"操作是否更新列值。如果为 false，则只能在第一次插入对象时编写该值。 默认值为"true"。
- `select: boolean` - 定义在进行查询时是否默认隐藏此列。 设置为 false 时，列数据不会显示标准查询。 默认情况下，列是 select：true
- `default: string` - 添加数据库级列的 DEFAULT 值。
- `primary: boolean` - 将列标记为主要列。 使用方式和@ PrimaryColumn 相同。
- `unique: boolean` - 将列标记为唯一列（创建唯一约束）。
- `comment: string` - 数据库列备注，并非所有数据库类型都支持。
- `precision: number` - 十进制（精确数字）列的精度（仅适用于十进制列），这是为值存储的最大位数。仅用于某些列类型。
- `scale: number` - 十进制（精确数字）列的比例（仅适用于十进制列），表示小数点右侧的位数，且不得大于精度。 仅用于某些列类型。
- `zerofill: boolean` - 将 ZEROFILL 属性设置为数字列。 仅在 MySQL 中使用。 如果是 true，MySQL 会自动将 UNSIGNED 属性添加到此列。
- `unsigned: boolean` - 将 UNSIGNED 属性设置为数字列。 仅在 MySQL 中使用。
- `charset: string` - 定义列字符集。 并非所有数据库类型都支持。
- `collation: string` - 定义列排序规则。
- `enum: string[]|AnyEnum` - 在 enum 列类型中使用，以指定允许的枚举值列表。 你也可以指定数组或指定枚举类。
- `asExpression: string` - 生成的列表达式。 仅在 MySQL (opens new window)中使用。
- `generatedType: "VIRTUAL"|"STORED"` - 生成的列类型。 仅在 MySQL (opens new window)中使用。
- `hstoreType: "object"|"string"` -返回 HSTORE 列类型。 以字符串或对象的形式返回值。 仅在 Postgres 中使用。
- `array: boolean` - 用于可以是数组的 postgres 列类型（例如 int []）
- `transformer: { from(value: DatabaseType): EntityType, to(value: EntityType): DatabaseType }` - 用于将任意类型 EntityType 的属性编组为数据库支持的类型 DatabaseType。
