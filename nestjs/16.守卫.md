## 守卫(guard)

守卫是一个用 @Injectable() 装饰器注释的类，它实现了 CanActivate 接口。
守卫有单一的责任。它们根据运行时存在的某些条件（如权限、角色、ACL 等）确定给定请求是否将由路由处理程序处理。这通常称为授权。
授权（及其通常与之合作的身份验证）通常由传统 Express 应用中的 中间件 处理。
中间件是身份验证的不错选择，因为诸如令牌验证和将属性附加到 request 对象之类的事情与特定路由上下文（及其元数据）没有紧密联系。

:::warning 注意事项
守卫在所有中间件之后、任何拦截器或管道之前执行。
:::

## 创建守卫

```sh
nest g gu verify
```

### 单独守卫

与管道和异常过滤器一样，防护可以是控制器范围、方法范围或全局作用域。
下面，我们使用 `@UseGuards()` 装饰器设置了一个控制器作用域的守卫。
这个装饰器可以接受一个参数，或者一个逗号分隔的参数列表。
这使你可以通过一个声明轻松应用一组适当的保护。

1. 守卫

```ts
import { CanActivate, ExecutionContext, Injectable } from "@nestjs/common";
import { Observable } from "rxjs";

@Injectable()
export class VerifyGuard implements CanActivate {
  /**
   *
   * @param context 上下文
   * @returns boolean 必须返回一个boolean值
   */
  canActivate(
    context: ExecutionContext
  ): boolean | Promise<boolean> | Observable<boolean> {
    console.log(context.switchToHttp().getRequest().query, 1111111111);
    // 做点什么，不通过返回false，通过返回true
    return true;
  }
}
```

2. 启用守卫

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
} from "@nestjs/common";
import { VerifyService } from "./verify.service";
import { CreateVerifyDto } from "./dto/create-verify.dto";
import { UpdateVerifyDto } from "./dto/update-verify.dto";
import { VerifyGuard } from "./verify.guard";

@Controller("verify")
export class VerifyController {
  constructor(private readonly verifyService: VerifyService) {}
  /**
   * 启用守卫,使用@UseGuards(目标守卫), 也可以自己实例化@UseGuards(new 目标守卫())
   */
  @Get()
  @UseGuards(VerifyGuard)
  findAll() {
    return this.verifyService.findAll();
  }
}
```

### 全局守卫

通过`useGlobalGuards`去注入全局守卫

```ts
// main.ts

import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import { VerifyGuard } from "./verify/verify.guard";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  // 启用全局守卫
  app.useGlobalGuards(new VerifyGuard());
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```

### 角色控制

`SetMetadata 装饰器`,第一个参数为`key`，第二个参数`自定义我们的例子是数组存放的权限`

1. verify.controller.ts

```ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  SetMetadata,
} from "@nestjs/common";
import { VerifyService } from "./verify.service";
import { CreateVerifyDto } from "./dto/create-verify.dto";
import { UpdateVerifyDto } from "./dto/update-verify.dto";
import { VerifyGuard } from "./verify.guard";

@Controller("verify")
@UseGuards(VerifyGuard) // 添加守卫
export class VerifyController {
  constructor(private readonly verifyService: VerifyService) {}

  @Post()
  create(@Body() createVerifyDto: CreateVerifyDto) {
    return this.verifyService.create(createVerifyDto);
  }

  /**
   * 启用守卫,使用@UseGuards(目标守卫), 也可以自己实例化@UseGuards(new 目标守卫())
   */
  @Get()
  // @UseGuards(VerifyGuard) // 单独验证单接口守卫
  @SetMetadata("name", ["admin", "member"]) // 添加角色控制
  findAll() {
    return this.verifyService.findAll();
  }
}
```

2. verify.guard.ts

```ts
import { CanActivate, ExecutionContext, Injectable } from "@nestjs/common";
import { Observable } from "rxjs";
import { Reflector } from "@nestjs/core";

@Injectable()
export class VerifyGuard implements CanActivate {
  constructor(private reflector: Reflector) {}
  /**
   *
   * @param context 上下文
   * @returns boolean 必须返回一个boolean值
   */
  canActivate(
    context: ExecutionContext
  ): boolean | Promise<boolean> | Observable<boolean> {
    // 做点什么，不通过返回false，通过返回true
    // console.log(context.switchToHttp().getRequest().headers, 1111111111);
    // return true;

    // 请求中的角色
    const name = context.switchToHttp().getRequest().headers?.name;
    // 验证角色白名单或者黑名单，也就是verify.controller.ts中使用@SetMetadata('name', ['admin', 'member'])设置的名单数组
    const names = this.reflector.get<string[]>("name", context.getHandler());
    try {
      return names.includes(name);
    } catch (error) {
      return true;
    }
  }
}
```
